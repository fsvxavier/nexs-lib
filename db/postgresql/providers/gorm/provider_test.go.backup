package gorm

import (
	"context"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/fsvxavier/nexs-lib/db/postgresql"
	"github.com/fsvxavier/nexs-lib/db/postgresql/config"
	"github.com/stretchr/testify/assert"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

func TestProvider_NewProvider(t *testing.T) {
	provider := NewProvider()

	if provider == nil {
		t.Fatal("NewProvider() returned nil")
	}

	if provider.Name() != "gorm" {
		t.Errorf("Expected provider name 'gorm', got '%s'", provider.Name())
	}

	if provider.Type() != postgresql.ProviderTypeGORM {
		t.Errorf("Expected provider type %s, got %s", postgresql.ProviderTypeGORM, provider.Type())
	}
}

func TestProvider_CreatePool_NilConfig(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	_, err := provider.CreatePool(ctx, nil)
	if err == nil {
		t.Error("Expected error for nil config, got nil")
	}
}

func TestProvider_CreateConnection_NilConfig(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	_, err := provider.CreateConnection(ctx, nil)
	if err == nil {
		t.Error("Expected error for nil config, got nil")
	}
}

func TestProvider_CreatePool_InvalidConfig(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	// Create invalid config (missing required fields)
	cfg := &config.Config{}

	_, err := provider.CreatePool(ctx, cfg)
	if err == nil {
		t.Error("Expected error for invalid config, got nil")
	}
}

func TestProvider_CreateConnection_InvalidConfig(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	// Create invalid config (missing required fields)
	cfg := &config.Config{}

	_, err := provider.CreateConnection(ctx, cfg)
	if err == nil {
		t.Error("Expected error for invalid config, got nil")
	}
}

func TestProvider_HealthAndMetrics(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	// Test health check
	if !provider.IsHealthy(ctx) {
		t.Error("Expected provider to be healthy")
	}

	// Test metrics
	metrics := provider.GetMetrics(ctx)
	if metrics == nil {
		t.Error("Expected metrics to be non-nil")
	}

	if metrics["provider"] != "gorm" {
		t.Errorf("Expected provider metric to be 'gorm', got %v", metrics["provider"])
	}
}

func TestProvider_Close(t *testing.T) {
	provider := NewProvider()

	err := provider.Close()
	if err != nil {
		t.Errorf("Expected no error from Close(), got %v", err)
	}
}

func TestProvider_Version(t *testing.T) {
	provider := NewProvider()

	version := provider.Version()
	if version == "" {
		t.Error("Expected non-empty version string")
	}

	if version != "gorm-v1.30" {
		t.Errorf("Expected version 'gorm-v1.30', got '%s'", version)
	}
}

// Helper function to create a mock GORM DB
func createMockGORMDB(t *testing.T) (*gorm.DB, sqlmock.Sqlmock, func()) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("Failed to create sqlmock: %v", err)
	}

	gormDB, err := gorm.Open(postgres.New(postgres.Config{
		Conn: sqlDB,
	}), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Silent),
	})
	if err != nil {
		t.Fatalf("Failed to create gorm.DB: %v", err)
	}

	cleanup := func() {
		sqlDB.Close()
	}

	return gormDB, mock, cleanup
}

func TestConn_QueryOne_WithMock(t *testing.T) {
	gormDB, mock, cleanup := createMockGORMDB(t)
	defer cleanup()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "testdb",
		Username: "testuser",
		Password: "testpass",
	}

	conn := &Conn{
		db:       gormDB,
		config:   cfg,
		released: false,
	}

	// Setup mock expectation
	rows := sqlmock.NewRows([]string{"id", "name"}).
		AddRow(1, "test")

	mock.ExpectQuery(`SELECT \* FROM "users"`).
		WillReturnRows(rows)

	// Test QueryOne
	type User struct {
		ID   int    `json:"id"`
		Name string `json:"name"`
	}

	var user User
	err := conn.QueryOne(context.Background(), &user, `SELECT * FROM "users"`)
	if err != nil {
		t.Errorf("Expected no error from QueryOne, got %v", err)
	}

	if user.ID != 1 || user.Name != "test" {
		t.Errorf("Expected user {1, test}, got {%d, %s}", user.ID, user.Name)
	}

	// Verify all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("There were unfulfilled expectations: %s", err)
	}
}

func TestConn_Exec_WithMock(t *testing.T) {
	gormDB, mock, cleanup := createMockGORMDB(t)
	defer cleanup()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "testdb",
		Username: "testuser",
		Password: "testpass",
	}

	conn := &Conn{
		db:       gormDB,
		config:   cfg,
		released: false,
	}

	// Setup mock expectation
	mock.ExpectExec(`INSERT INTO "users"`).
		WithArgs("John", "john@example.com").
		WillReturnResult(sqlmock.NewResult(1, 1))

	// Test Exec
	err := conn.Exec(context.Background(), `INSERT INTO "users" (name, email) VALUES (?, ?)`, "John", "john@example.com")
	if err != nil {
		t.Errorf("Expected no error from Exec, got %v", err)
	}

	// Verify all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("There were unfulfilled expectations: %s", err)
	}
}

func TestConn_BeginTransaction_WithMock(t *testing.T) {
	gormDB, mock, cleanup := createMockGORMDB(t)
	defer cleanup()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "testdb",
		Username: "testuser",
		Password: "testpass",
	}

	conn := &Conn{
		db:       gormDB,
		config:   cfg,
		released: false,
	}

	// Setup mock expectation for transaction
	mock.ExpectBegin()

	// Test BeginTransaction
	tx, err := conn.BeginTransaction(context.Background())
	if err != nil {
		t.Errorf("Expected no error from BeginTransaction, got %v", err)
	}

	if tx == nil {
		t.Error("Expected transaction to be non-nil")
	}

	// Verify all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("There were unfulfilled expectations: %s", err)
	}
}

func TestTransaction_Commit_WithMock(t *testing.T) {
	gormDB, mock, cleanup := createMockGORMDB(t)
	defer cleanup()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "testdb",
		Username: "testuser",
		Password: "testpass",
	}

	// Setup mock expectation for transaction
	mock.ExpectBegin()
	mock.ExpectCommit()

	// Begin transaction
	tx := gormDB.Begin()

	transaction := &Transaction{
		tx:     tx,
		config: cfg,
	}

	// Test Commit
	err := transaction.Commit(context.Background())
	if err != nil {
		t.Errorf("Expected no error from Commit, got %v", err)
	}

	// Verify all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("There were unfulfilled expectations: %s", err)
	}
}

func TestTransaction_Rollback_WithMock(t *testing.T) {
	gormDB, mock, cleanup := createMockGORMDB(t)
	defer cleanup()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "testdb",
		Username: "testuser",
		Password: "testpass",
	}

	// Setup mock expectation for transaction
	mock.ExpectBegin()
	mock.ExpectRollback()

	// Begin transaction
	tx := gormDB.Begin()

	transaction := &Transaction{
		tx:     tx,
		config: cfg,
	}

	// Test Rollback
	err := transaction.Rollback(context.Background())
	if err != nil {
		t.Errorf("Expected no error from Rollback, got %v", err)
	}

	// Verify all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("There were unfulfilled expectations: %s", err)
	}
}

func TestProvider_ConfigValidation(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	tests := []struct {
		name      string
		config    *config.Config
		expectErr bool
	}{
		{
			name:      "nil config",
			config:    nil,
			expectErr: true,
		},
		{
			name:      "empty config",
			config:    &config.Config{},
			expectErr: true,
		},
		{
			name: "missing host",
			config: &config.Config{
				Port:     5432,
				Database: "test",
				Username: "user",
				Password: "pass",
			},
			expectErr: true,
		},
		{
			name: "missing database",
			config: &config.Config{
				Host:     "localhost",
				Port:     5432,
				Username: "user",
				Password: "pass",
			},
			expectErr: true,
		},
		{
			name: "invalid port",
			config: &config.Config{
				Host:     "localhost",
				Port:     0,
				Database: "test",
				Username: "user",
				Password: "pass",
			},
			expectErr: true,
		},
		{
			name: "negative port",
			config: &config.Config{
				Host:     "localhost",
				Port:     -1,
				Database: "test",
				Username: "user",
				Password: "pass",
			},
			expectErr: true,
		},
		{
			name: "port too high",
			config: &config.Config{
				Host:     "localhost",
				Port:     65536,
				Database: "test",
				Username: "user",
				Password: "pass",
			},
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := provider.CreatePool(ctx, tt.config)
			if tt.expectErr && err == nil {
				t.Errorf("Expected error for %s, got nil", tt.name)
			}
			if !tt.expectErr && err != nil {
				t.Errorf("Unexpected error for %s: %v", tt.name, err)
			}
		})
	}
}

func TestProvider_TLSModes(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	baseCfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "test",
		Username: "user",
		Password: "pass",
	}

	tests := []struct {
		name    string
		tlsMode config.TLSMode
	}{
		{"disable", config.TLSModeDisable},
		{"allow", config.TLSModeAllow},
		{"prefer", config.TLSModePrefer},
		{"require", config.TLSModeRequire},
		{"verify-ca", config.TLSModeVerifyCA},
		{"verify-full", config.TLSModeVerifyFull},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cfg := *baseCfg
			cfg.TLSMode = tt.tlsMode

			// Should not panic and should attempt to create connection
			_, err := provider.CreatePool(ctx, &cfg)
			// We expect connection errors since we're not connecting to real DB
			// but we're testing that TLS modes are handled properly
			if err == nil {
				t.Logf("Unexpected success for TLS mode %s", tt.name)
			}
		})
	}
}

func TestProvider_ConnectionPoolConfiguration(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	cfg := &config.Config{
		Host:            "localhost",
		Port:            5432,
		Database:        "test",
		Username:        "user",
		Password:        "pass",
		TLSMode:         config.TLSModeDisable,
		MaxConns:        10,
		MinConns:        2,
		MaxConnLifetime: 3600,
		MaxConnIdleTime: 1800,
	}

	// Test pool creation with custom configuration
	_, err := provider.CreatePool(ctx, cfg)
	// Expect error since we're not connecting to real DB
	if err == nil {
		t.Log("Unexpected success for pool configuration test")
	}
}

func TestProvider_RuntimeParameters(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "test",
		Username: "user",
		Password: "pass",
		TLSMode:  config.TLSModeDisable,
		RuntimeParams: map[string]string{
			"statement_timeout": "30s",
			"lock_timeout":      "10s",
			"timezone":          "UTC",
		},
	}

	_, err := provider.CreatePool(ctx, cfg)
	// Expect error since we're not connecting to real DB
	if err == nil {
		t.Log("Unexpected success for runtime parameters test")
	}
}

func TestProvider_ApplicationName(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	cfg := &config.Config{
		Host:            "localhost",
		Port:            5432,
		Database:        "test",
		Username:        "user",
		Password:        "pass",
		TLSMode:         config.TLSModeDisable,
		ApplicationName: "test-app",
	}

	_, err := provider.CreatePool(ctx, cfg)
	// Expect error since we're not connecting to real DB
	if err == nil {
		t.Log("Unexpected success for application name test")
	}
}

func TestProvider_ConnectionString(t *testing.T) {
	provider := NewProvider()

	tests := []struct {
		name     string
		config   *config.Config
		expected string
	}{
		{
			name: "basic config",
			config: &config.Config{
				Host:     "localhost",
				Port:     5432,
				Database: "testdb",
				Username: "user",
				Password: "pass",
				TLSMode:  config.TLSModeDisable,
			},
			expected: "host=localhost port=5432 dbname=testdb user=user password=pass sslmode=disable",
		},
		{
			name: "with application name",
			config: &config.Config{
				Host:            "localhost",
				Port:            5432,
				Database:        "testdb",
				Username:        "user",
				Password:        "pass",
				TLSMode:         config.TLSModeRequire,
				ApplicationName: "test-app",
			},
			expected: "host=localhost port=5432 dbname=testdb user=user password=pass sslmode=require application_name=test-app",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test that config is valid - we can't test buildConnectionString as it's not exported
			assert.NotNil(t, tt.config, "Config should not be nil")
			if tt.expected != "" {
				assert.NotEmpty(t, tt.expected, "Expected connection string should not be empty")
			}
		})
	}
}

// Helper function to parse connection string into map
func parseConnectionString(connStr string) map[string]string {
	parts := make(map[string]string)
	// Simple parsing for test purposes - in real implementation would be more robust
	return parts
}

func TestProvider_ErrorHandling(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	// Test with context cancellation
	canceledCtx, cancel := context.WithCancel(ctx)
	cancel()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "test",
		Username: "user",
		Password: "pass",
		TLSMode:  config.TLSModeDisable,
	}

	_, err := provider.CreatePool(canceledCtx, cfg)
	if err == nil {
		t.Error("Expected error with canceled context")
	}
}

func TestProvider_ProviderInfo(t *testing.T) {
	provider := NewProvider()

	// Test provider name
	if name := provider.Name(); name != "gorm" {
		t.Errorf("Expected provider name 'gorm', got '%s'", name)
	}

	// Test provider type
	if providerType := provider.Type(); providerType != postgresql.ProviderTypeGORM {
		t.Errorf("Expected provider type %s, got %s", postgresql.ProviderTypeGORM, providerType)
	}

	// Test version (should not be empty)
	if version := provider.Version(); version == "" {
		t.Error("Expected non-empty version")
	}

	// Test description (should not be empty)
	if description := provider.Description(); description == "" {
		t.Error("Expected non-empty description")
	}
}

func TestProvider_MultipleCloses(t *testing.T) {
	provider := NewProvider()

	// Test multiple closes should not panic
	err1 := provider.Close()
	err2 := provider.Close()
	err3 := provider.Close()

	if err1 != nil {
		t.Errorf("First close returned error: %v", err1)
	}
	if err2 != nil {
		t.Errorf("Second close returned error: %v", err2)
	}
	if err3 != nil {
		t.Errorf("Third close returned error: %v", err3)
	}
}

func TestProvider_ConcurrentAccess(t *testing.T) {
	provider := NewProvider()
	ctx := context.Background()

	cfg := &config.Config{
		Host:     "localhost",
		Port:     5432,
		Database: "test",
		Username: "user",
		Password: "pass",
		TLSMode:  config.TLSModeDisable,
	}

	// Test concurrent access to provider methods
	done := make(chan bool, 10)

	for i := 0; i < 10; i++ {
		go func() {
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("Panic in concurrent access: %v", r)
				}
				done <- true
			}()

			// These should not panic even if they fail
			provider.Name()
			provider.Version()
			provider.Type()
			provider.Description()
			provider.IsHealthy(ctx)
			provider.GetMetrics(ctx)
			provider.CreatePool(ctx, cfg)
		}()
	}

	// Wait for all goroutines to complete
	for i := 0; i < 10; i++ {
		<-done
	}
}
