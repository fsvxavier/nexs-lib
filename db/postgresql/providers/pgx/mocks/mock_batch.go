//go:build unit

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/fsvxavier/nexs-lib/db/postgresql (interfaces: IBatch,IBatchResults,IRows,IRow)

package mocks

import (
	"reflect"

	"github.com/fsvxavier/nexs-lib/db/postgresql"
	"github.com/golang/mock/gomock"
)

// MockIBatch is a mock of IBatch interface.
type MockIBatch struct {
	ctrl     *gomock.Controller
	recorder *MockIBatchMockRecorder
}

// MockIBatchMockRecorder is the mock recorder for MockIBatch.
type MockIBatchMockRecorder struct {
	mock *MockIBatch
}

// NewMockIBatch creates a new mock instance.
func NewMockIBatch(ctrl *gomock.Controller) *MockIBatch {
	mock := &MockIBatch{ctrl: ctrl}
	mock.recorder = &MockIBatchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIBatch) EXPECT() *MockIBatchMockRecorder {
	return m.recorder
}

// Clear mocks base method.
func (m *MockIBatch) Clear() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Clear")
}

// Clear indicates an expected call of Clear.
func (mr *MockIBatchMockRecorder) Clear() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockIBatch)(nil).Clear))
}

// Exec mocks base method.
func (m *MockIBatch) Exec(query string, args ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Exec", varargs...)
}

// Exec indicates an expected call of Exec.
func (mr *MockIBatchMockRecorder) Exec(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIBatch)(nil).Exec), varargs...)
}

// Len mocks base method.
func (m *MockIBatch) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockIBatchMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockIBatch)(nil).Len))
}

// Query mocks base method.
func (m *MockIBatch) Query(query string, args ...interface{}) {
	m.ctrl.T.Helper()
	varargs := []interface{}{query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Query", varargs...)
}

// Query indicates an expected call of Query.
func (mr *MockIBatchMockRecorder) Query(query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIBatch)(nil).Query), varargs...)
}

// MockIBatchResults is a mock of IBatchResults interface.
type MockIBatchResults struct {
	ctrl     *gomock.Controller
	recorder *MockIBatchResultsMockRecorder
}

// MockIBatchResultsMockRecorder is the mock recorder for MockIBatchResults.
type MockIBatchResultsMockRecorder struct {
	mock *MockIBatchResults
}

// NewMockIBatchResults creates a new mock instance.
func NewMockIBatchResults(ctrl *gomock.Controller) *MockIBatchResults {
	mock := &MockIBatchResults{ctrl: ctrl}
	mock.recorder = &MockIBatchResultsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIBatchResults) EXPECT() *MockIBatchResultsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIBatchResults) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockIBatchResultsMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIBatchResults)(nil).Close))
}

// Exec mocks base method.
func (m *MockIBatchResults) Exec() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec")
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockIBatchResultsMockRecorder) Exec() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIBatchResults)(nil).Exec))
}

// Query mocks base method.
func (m *MockIBatchResults) Query() (postgresql.IRows, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query")
	ret0, _ := ret[0].(postgresql.IRows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockIBatchResultsMockRecorder) Query() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIBatchResults)(nil).Query))
}

// QueryRow mocks base method.
func (m *MockIBatchResults) QueryRow() postgresql.IRow {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryRow")
	ret0, _ := ret[0].(postgresql.IRow)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockIBatchResultsMockRecorder) QueryRow() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockIBatchResults)(nil).QueryRow))
}

// MockIRows is a mock of IRows interface.
type MockIRows struct {
	ctrl     *gomock.Controller
	recorder *MockIRowsMockRecorder
}

// MockIRowsMockRecorder is the mock recorder for MockIRows.
type MockIRowsMockRecorder struct {
	mock *MockIRows
}

// NewMockIRows creates a new mock instance.
func NewMockIRows(ctrl *gomock.Controller) *MockIRows {
	mock := &MockIRows{ctrl: ctrl}
	mock.recorder = &MockIRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIRows) EXPECT() *MockIRowsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockIRows) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close.
func (mr *MockIRowsMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIRows)(nil).Close))
}

// Err mocks base method.
func (m *MockIRows) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockIRowsMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockIRows)(nil).Err))
}

// Next mocks base method.
func (m *MockIRows) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockIRowsMockRecorder) Next() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockIRows)(nil).Next))
}

// Scan mocks base method.
func (m *MockIRows) Scan(dest ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockIRowsMockRecorder) Scan(dest ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIRows)(nil).Scan), dest...)
}

// MockIRow is a mock of IRow interface.
type MockIRow struct {
	ctrl     *gomock.Controller
	recorder *MockIRowMockRecorder
}

// MockIRowMockRecorder is the mock recorder for MockIRow.
type MockIRowMockRecorder struct {
	mock *MockIRow
}

// NewMockIRow creates a new mock instance.
func NewMockIRow(ctrl *gomock.Controller) *MockIRow {
	mock := &MockIRow{ctrl: ctrl}
	mock.recorder = &MockIRowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIRow) EXPECT() *MockIRowMockRecorder {
	return m.recorder
}

// Scan mocks base method.
func (m *MockIRow) Scan(dest ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range dest {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockIRowMockRecorder) Scan(dest ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIRow)(nil).Scan), dest...)
}
