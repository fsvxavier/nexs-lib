//go:build unit

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/fsvxavier/nexs-lib/db/postgresql (interfaces: IConn)

package mocks

import (
	"context"
	"reflect"
	"time"

	"github.com/fsvxavier/nexs-lib/db/postgresql"
	"github.com/golang/mock/gomock"
)

// MockIConn is a mock of IConn interface.
type MockIConn struct {
	ctrl     *gomock.Controller
	recorder *MockIConnMockRecorder
}

// MockIConnMockRecorder is the mock recorder for MockIConn.
type MockIConnMockRecorder struct {
	mock *MockIConn
}

// NewMockIConn creates a new mock instance.
func NewMockIConn(ctrl *gomock.Controller) *MockIConn {
	mock := &MockIConn{ctrl: ctrl}
	mock.recorder = &MockIConnMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIConn) EXPECT() *MockIConnMockRecorder {
	return m.recorder
}

// AfterAcquireHook mocks base method.
func (m *MockIConn) AfterAcquireHook(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AfterAcquireHook", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// AfterAcquireHook indicates an expected call of AfterAcquireHook.
func (mr *MockIConnMockRecorder) AfterAcquireHook(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterAcquireHook", reflect.TypeOf((*MockIConn)(nil).AfterAcquireHook), ctx)
}

// BeforeReleaseHook mocks base method.
func (m *MockIConn) BeforeReleaseHook(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeforeReleaseHook", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// BeforeReleaseHook indicates an expected call of BeforeReleaseHook.
func (mr *MockIConnMockRecorder) BeforeReleaseHook(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeReleaseHook", reflect.TypeOf((*MockIConn)(nil).BeforeReleaseHook), ctx)
}

// BeginTransaction mocks base method.
func (m *MockIConn) BeginTransaction(ctx context.Context) (postgresql.ITransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTransaction", ctx)
	ret0, _ := ret[0].(postgresql.ITransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTransaction indicates an expected call of BeginTransaction.
func (mr *MockIConnMockRecorder) BeginTransaction(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTransaction", reflect.TypeOf((*MockIConn)(nil).BeginTransaction), ctx)
}

// BeginTransactionWithOptions mocks base method.
func (m *MockIConn) BeginTransactionWithOptions(ctx context.Context, opts postgresql.TxOptions) (postgresql.ITransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTransactionWithOptions", ctx, opts)
	ret0, _ := ret[0].(postgresql.ITransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTransactionWithOptions indicates an expected call of BeginTransactionWithOptions.
func (mr *MockIConnMockRecorder) BeginTransactionWithOptions(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTransactionWithOptions", reflect.TypeOf((*MockIConn)(nil).BeginTransactionWithOptions), ctx, opts)
}

// Exec mocks base method.
func (m *MockIConn) Exec(ctx context.Context, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockIConnMockRecorder) Exec(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIConn)(nil).Exec), varargs...)
}

// Listen mocks base method.
func (m *MockIConn) Listen(ctx context.Context, channel string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Listen", ctx, channel)
	ret0, _ := ret[0].(error)
	return ret0
}

// Listen indicates an expected call of Listen.
func (mr *MockIConnMockRecorder) Listen(ctx, channel interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Listen", reflect.TypeOf((*MockIConn)(nil).Listen), ctx, channel)
}

// Ping mocks base method.
func (m *MockIConn) Ping(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockIConnMockRecorder) Ping(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockIConn)(nil).Ping), ctx)
}

// Prepare mocks base method.
func (m *MockIConn) Prepare(ctx context.Context, name, query string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", ctx, name, query)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prepare indicates an expected call of Prepare.
func (mr *MockIConnMockRecorder) Prepare(ctx, name, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockIConn)(nil).Prepare), ctx, name, query)
}

// Query mocks base method.
func (m *MockIConn) Query(ctx context.Context, query string, args ...interface{}) (postgresql.IRows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(postgresql.IRows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockIConnMockRecorder) Query(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIConn)(nil).Query), varargs...)
}

// QueryAll mocks base method.
func (m *MockIConn) QueryAll(ctx context.Context, dst interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dst, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryAll", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryAll indicates an expected call of QueryAll.
func (mr *MockIConnMockRecorder) QueryAll(ctx, dst, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dst, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryAll", reflect.TypeOf((*MockIConn)(nil).QueryAll), varargs...)
}

// QueryCount mocks base method.
func (m *MockIConn) QueryCount(ctx context.Context, query string, args ...interface{}) (*int, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryCount", varargs...)
	ret0, _ := ret[0].(*int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryCount indicates an expected call of QueryCount.
func (mr *MockIConnMockRecorder) QueryCount(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryCount", reflect.TypeOf((*MockIConn)(nil).QueryCount), varargs...)
}

// QueryOne mocks base method.
func (m *MockIConn) QueryOne(ctx context.Context, dst interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dst, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOne", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryOne indicates an expected call of QueryOne.
func (mr *MockIConnMockRecorder) QueryOne(ctx, dst, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dst, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOne", reflect.TypeOf((*MockIConn)(nil).QueryOne), varargs...)
}

// QueryRow mocks base method.
func (m *MockIConn) QueryRow(ctx context.Context, query string, args ...interface{}) (postgresql.IRow, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(postgresql.IRow)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockIConnMockRecorder) QueryRow(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockIConn)(nil).QueryRow), varargs...)
}

// Release mocks base method.
func (m *MockIConn) Release(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release", ctx)
}

// Release indicates an expected call of Release.
func (mr *MockIConnMockRecorder) Release(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockIConn)(nil).Release), ctx)
}

// SendBatch mocks base method.
func (m *MockIConn) SendBatch(ctx context.Context, batch postgresql.IBatch) (postgresql.IBatchResults, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendBatch", ctx, batch)
	ret0, _ := ret[0].(postgresql.IBatchResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendBatch indicates an expected call of SendBatch.
func (mr *MockIConnMockRecorder) SendBatch(ctx, batch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendBatch", reflect.TypeOf((*MockIConn)(nil).SendBatch), ctx, batch)
}

// Unlisten mocks base method.
func (m *MockIConn) Unlisten(ctx context.Context, channel string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlisten", ctx, channel)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlisten indicates an expected call of Unlisten.
func (mr *MockIConnMockRecorder) Unlisten(ctx, channel interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlisten", reflect.TypeOf((*MockIConn)(nil).Unlisten), ctx, channel)
}

// WaitForNotification mocks base method.
func (m *MockIConn) WaitForNotification(ctx context.Context, timeout time.Duration) (*postgresql.Notification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForNotification", ctx, timeout)
	ret0, _ := ret[0].(*postgresql.Notification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitForNotification indicates an expected call of WaitForNotification.
func (mr *MockIConnMockRecorder) WaitForNotification(ctx, timeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForNotification", reflect.TypeOf((*MockIConn)(nil).WaitForNotification), ctx, timeout)
}
