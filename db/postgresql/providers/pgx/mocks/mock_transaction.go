//go:build unit

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/fsvxavier/nexs-lib/db/postgresql (interfaces: ITransaction)

package mocks

import (
	"context"
	"reflect"
	"time"

	"github.com/fsvxavier/nexs-lib/db/postgresql"
	"github.com/golang/mock/gomock"
)

// MockITransaction is a mock of ITransaction interface.
type MockITransaction struct {
	ctrl     *gomock.Controller
	recorder *MockITransactionMockRecorder
}

// MockITransactionMockRecorder is the mock recorder for MockITransaction.
type MockITransactionMockRecorder struct {
	mock *MockITransaction
}

// NewMockITransaction creates a new mock instance.
func NewMockITransaction(ctrl *gomock.Controller) *MockITransaction {
	mock := &MockITransaction{ctrl: ctrl}
	mock.recorder = &MockITransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockITransaction) EXPECT() *MockITransactionMockRecorder {
	return m.recorder
}

// AfterAcquireHook mocks base method.
func (m *MockITransaction) AfterAcquireHook(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AfterAcquireHook", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// AfterAcquireHook indicates an expected call of AfterAcquireHook.
func (mr *MockITransactionMockRecorder) AfterAcquireHook(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AfterAcquireHook", reflect.TypeOf((*MockITransaction)(nil).AfterAcquireHook), ctx)
}

// BeforeReleaseHook mocks base method.
func (m *MockITransaction) BeforeReleaseHook(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeforeReleaseHook", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// BeforeReleaseHook indicates an expected call of BeforeReleaseHook.
func (mr *MockITransactionMockRecorder) BeforeReleaseHook(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeforeReleaseHook", reflect.TypeOf((*MockITransaction)(nil).BeforeReleaseHook), ctx)
}

// BeginTransaction mocks base method.
func (m *MockITransaction) BeginTransaction(ctx context.Context) (postgresql.ITransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTransaction", ctx)
	ret0, _ := ret[0].(postgresql.ITransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTransaction indicates an expected call of BeginTransaction.
func (mr *MockITransactionMockRecorder) BeginTransaction(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTransaction", reflect.TypeOf((*MockITransaction)(nil).BeginTransaction), ctx)
}

// BeginTransactionWithOptions mocks base method.
func (m *MockITransaction) BeginTransactionWithOptions(ctx context.Context, opts postgresql.TxOptions) (postgresql.ITransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTransactionWithOptions", ctx, opts)
	ret0, _ := ret[0].(postgresql.ITransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTransactionWithOptions indicates an expected call of BeginTransactionWithOptions.
func (mr *MockITransactionMockRecorder) BeginTransactionWithOptions(ctx, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTransactionWithOptions", reflect.TypeOf((*MockITransaction)(nil).BeginTransactionWithOptions), ctx, opts)
}

// Commit mocks base method.
func (m *MockITransaction) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockITransactionMockRecorder) Commit(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockITransaction)(nil).Commit), ctx)
}

// Exec mocks base method.
func (m *MockITransaction) Exec(ctx context.Context, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec.
func (mr *MockITransactionMockRecorder) Exec(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockITransaction)(nil).Exec), varargs...)
}

// Listen mocks base method.
func (m *MockITransaction) Listen(ctx context.Context, channel string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Listen", ctx, channel)
	ret0, _ := ret[0].(error)
	return ret0
}

// Listen indicates an expected call of Listen.
func (mr *MockITransactionMockRecorder) Listen(ctx, channel interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Listen", reflect.TypeOf((*MockITransaction)(nil).Listen), ctx, channel)
}

// Ping mocks base method.
func (m *MockITransaction) Ping(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Ping", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Ping indicates an expected call of Ping.
func (mr *MockITransactionMockRecorder) Ping(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ping", reflect.TypeOf((*MockITransaction)(nil).Ping), ctx)
}

// Prepare mocks base method.
func (m *MockITransaction) Prepare(ctx context.Context, name, query string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", ctx, name, query)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prepare indicates an expected call of Prepare.
func (mr *MockITransactionMockRecorder) Prepare(ctx, name, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockITransaction)(nil).Prepare), ctx, name, query)
}

// Query mocks base method.
func (m *MockITransaction) Query(ctx context.Context, query string, args ...interface{}) (postgresql.IRows, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(postgresql.IRows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockITransactionMockRecorder) Query(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockITransaction)(nil).Query), varargs...)
}

// QueryAll mocks base method.
func (m *MockITransaction) QueryAll(ctx context.Context, dst interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dst, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryAll", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryAll indicates an expected call of QueryAll.
func (mr *MockITransactionMockRecorder) QueryAll(ctx, dst, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dst, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryAll", reflect.TypeOf((*MockITransaction)(nil).QueryAll), varargs...)
}

// QueryCount mocks base method.
func (m *MockITransaction) QueryCount(ctx context.Context, query string, args ...interface{}) (*int, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryCount", varargs...)
	ret0, _ := ret[0].(*int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryCount indicates an expected call of QueryCount.
func (mr *MockITransactionMockRecorder) QueryCount(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryCount", reflect.TypeOf((*MockITransaction)(nil).QueryCount), varargs...)
}

// QueryOne mocks base method.
func (m *MockITransaction) QueryOne(ctx context.Context, dst interface{}, query string, args ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, dst, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryOne", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueryOne indicates an expected call of QueryOne.
func (mr *MockITransactionMockRecorder) QueryOne(ctx, dst, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, dst, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryOne", reflect.TypeOf((*MockITransaction)(nil).QueryOne), varargs...)
}

// QueryRow mocks base method.
func (m *MockITransaction) QueryRow(ctx context.Context, query string, args ...interface{}) (postgresql.IRow, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, query}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(postgresql.IRow)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockITransactionMockRecorder) QueryRow(ctx, query interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, query}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockITransaction)(nil).QueryRow), varargs...)
}

// Release mocks base method.
func (m *MockITransaction) Release(ctx context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Release", ctx)
}

// Release indicates an expected call of Release.
func (mr *MockITransactionMockRecorder) Release(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockITransaction)(nil).Release), ctx)
}

// ReleaseSavepoint mocks base method.
func (m *MockITransaction) ReleaseSavepoint(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReleaseSavepoint", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReleaseSavepoint indicates an expected call of ReleaseSavepoint.
func (mr *MockITransactionMockRecorder) ReleaseSavepoint(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseSavepoint", reflect.TypeOf((*MockITransaction)(nil).ReleaseSavepoint), ctx, name)
}

// Rollback mocks base method.
func (m *MockITransaction) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockITransactionMockRecorder) Rollback(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockITransaction)(nil).Rollback), ctx)
}

// RollbackToSavepoint mocks base method.
func (m *MockITransaction) RollbackToSavepoint(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RollbackToSavepoint", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// RollbackToSavepoint indicates an expected call of RollbackToSavepoint.
func (mr *MockITransactionMockRecorder) RollbackToSavepoint(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RollbackToSavepoint", reflect.TypeOf((*MockITransaction)(nil).RollbackToSavepoint), ctx, name)
}

// Savepoint mocks base method.
func (m *MockITransaction) Savepoint(ctx context.Context, name string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Savepoint", ctx, name)
	ret0, _ := ret[0].(error)
	return ret0
}

// Savepoint indicates an expected call of Savepoint.
func (mr *MockITransactionMockRecorder) Savepoint(ctx, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Savepoint", reflect.TypeOf((*MockITransaction)(nil).Savepoint), ctx, name)
}

// SendBatch mocks base method.
func (m *MockITransaction) SendBatch(ctx context.Context, batch postgresql.IBatch) (postgresql.IBatchResults, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendBatch", ctx, batch)
	ret0, _ := ret[0].(postgresql.IBatchResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendBatch indicates an expected call of SendBatch.
func (mr *MockITransactionMockRecorder) SendBatch(ctx, batch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendBatch", reflect.TypeOf((*MockITransaction)(nil).SendBatch), ctx, batch)
}

// Unlisten mocks base method.
func (m *MockITransaction) Unlisten(ctx context.Context, channel string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlisten", ctx, channel)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlisten indicates an expected call of Unlisten.
func (mr *MockITransactionMockRecorder) Unlisten(ctx, channel interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlisten", reflect.TypeOf((*MockITransaction)(nil).Unlisten), ctx, channel)
}

// WaitForNotification mocks base method.
func (m *MockITransaction) WaitForNotification(ctx context.Context, timeout time.Duration) (*postgresql.Notification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WaitForNotification", ctx, timeout)
	ret0, _ := ret[0].(*postgresql.Notification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WaitForNotification indicates an expected call of WaitForNotification.
func (mr *MockITransactionMockRecorder) WaitForNotification(ctx, timeout interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForNotification", reflect.TypeOf((*MockITransaction)(nil).WaitForNotification), ctx, timeout)
}
