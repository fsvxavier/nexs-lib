package main

import (
	"encoding/json"
	"fmt"
	"net/url"
	"strconv"
	"strings"

	"github.com/fsvxavier/nexs-lib/domainerrors"
	"github.com/fsvxavier/nexs-lib/pagination"
	"github.com/fsvxavier/nexs-lib/pagination/config"
)

// ErrorScenario representa um cen√°rio de teste de erro
type ErrorScenario struct {
	Name        string
	Description string
	Params      url.Values
	SortFields  []string
	ExpectedErr string
}

// APIErrorResponse representa uma resposta de erro formatada
type APIErrorResponse struct {
	Error     string                 `json:"error"`
	Code      string                 `json:"code"`
	Message   string                 `json:"message"`
	Details   map[string]interface{} `json:"details,omitempty"`
	Timestamp string                 `json:"timestamp"`
	RequestID string                 `json:"request_id,omitempty"`
}

func createErrorScenarios() []ErrorScenario {
	return []ErrorScenario{
		{
			Name:        "P√°gina Inv√°lida - Texto",
			Description: "Par√¢metro page com valor n√£o num√©rico",
			Params: url.Values{
				"page": []string{"abc"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_PAGE_PARAMETER",
		},
		{
			Name:        "P√°gina Inv√°lida - Negativa",
			Description: "N√∫mero de p√°gina negativo",
			Params: url.Values{
				"page": []string{"-1"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_PAGE_PARAMETER",
		},
		{
			Name:        "P√°gina Inv√°lida - Zero",
			Description: "P√°gina zero (primeira p√°gina √© 1)",
			Params: url.Values{
				"page": []string{"0"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_PAGE_PARAMETER",
		},
		{
			Name:        "Limite Inv√°lido - Texto",
			Description: "Par√¢metro limit com valor n√£o num√©rico",
			Params: url.Values{
				"limit": []string{"xyz"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_LIMIT_PARAMETER",
		},
		{
			Name:        "Limite Inv√°lido - Negativo",
			Description: "Limite negativo",
			Params: url.Values{
				"limit": []string{"-10"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_LIMIT_PARAMETER",
		},
		{
			Name:        "Limite Inv√°lido - Zero",
			Description: "Limite zero",
			Params: url.Values{
				"limit": []string{"0"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_LIMIT_PARAMETER",
		},
		{
			Name:        "Limite Excede M√°ximo",
			Description: "Limite maior que o m√°ximo permitido",
			Params: url.Values{
				"limit": []string{"500"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "LIMIT_TOO_LARGE",
		},
		{
			Name:        "Campo de Ordena√ß√£o Inv√°lido",
			Description: "Campo de ordena√ß√£o n√£o permitido",
			Params: url.Values{
				"sort": []string{"password"},
			},
			SortFields:  []string{"id", "name", "email"},
			ExpectedErr: "INVALID_SORT_FIELD",
		},
		{
			Name:        "Ordem de Classifica√ß√£o Inv√°lida",
			Description: "Ordem que n√£o seja asc ou desc",
			Params: url.Values{
				"order": []string{"random"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_SORT_ORDER",
		},
		{
			Name:        "M√∫ltiplos Erros",
			Description: "M√∫ltiplos par√¢metros inv√°lidos simult√¢neos",
			Params: url.Values{
				"page":  []string{"-5"},
				"limit": []string{"abc"},
				"sort":  []string{"invalid_field"},
				"order": []string{"random"},
			},
			SortFields:  []string{"id", "name"},
			ExpectedErr: "INVALID_PAGE_PARAMETER", // Primeiro erro encontrado
		},
	}
}

func formatDomainError(err error) *APIErrorResponse {
	// Verificar se √© um domain error
	if domainErr, ok := err.(*domainerrors.DomainError); ok {
		return &APIErrorResponse{
			Error:   "Validation Failed",
			Code:    domainErr.Code,
			Message: domainErr.Message,
			Details: map[string]interface{}{
				"type":       domainErr.Type,
				"field":      extractFieldFromError(domainErr.Message),
				"suggestion": generateSuggestion(domainErr.Code),
			},
			Timestamp: "2024-01-01T12:00:00Z",
			RequestID: "req-" + generateRequestID(),
		}
	}

	// Erro gen√©rico
	return &APIErrorResponse{
		Error:     "Internal Error",
		Code:      "UNKNOWN_ERROR",
		Message:   err.Error(),
		Timestamp: "2024-01-01T12:00:00Z",
		RequestID: "req-" + generateRequestID(),
	}
}

func extractFieldFromError(message string) string {
	// Extrair campo do erro baseado na mensagem
	if strings.Contains(message, "page") {
		return "page"
	}
	if strings.Contains(message, "limit") {
		return "limit"
	}
	if strings.Contains(message, "sort") {
		return "sort"
	}
	if strings.Contains(message, "order") {
		return "order"
	}
	return "unknown"
}

func generateSuggestion(code string) string {
	suggestions := map[string]string{
		"INVALID_PAGE_PARAMETER":  "Use um n√∫mero inteiro positivo para a p√°gina (ex: page=1)",
		"INVALID_LIMIT_PARAMETER": "Use um n√∫mero inteiro positivo para o limite (ex: limit=10)",
		"LIMIT_TOO_LARGE":         "Reduza o limite para um valor menor ou igual ao m√°ximo permitido",
		"INVALID_SORT_FIELD":      "Use um campo de ordena√ß√£o v√°lido da lista permitida",
		"INVALID_SORT_ORDER":      "Use 'asc' para crescente ou 'desc' para decrescente",
	}

	if suggestion, exists := suggestions[code]; exists {
		return suggestion
	}
	return "Verifique a documenta√ß√£o da API para par√¢metros v√°lidos"
}

func generateRequestID() string {
	// Simular gera√ß√£o de request ID
	return fmt.Sprintf("%d", 12345)
}

func demonstrateErrorScenarios() {
	fmt.Println("=== 1. Demonstra√ß√£o de Cen√°rios de Erro ===")

	// Configurar servi√ßo com limites restritivos para demonstra√ß√£o
	cfg := config.NewDefaultConfig()
	cfg.MaxLimit = 100
	service := pagination.NewPaginationService(cfg)

	scenarios := createErrorScenarios()

	for i, scenario := range scenarios {
		fmt.Printf("\nüß™ Teste %d: %s\n", i+1, scenario.Name)
		fmt.Printf("üìù Descri√ß√£o: %s\n", scenario.Description)
		fmt.Printf("üîó Par√¢metros: %s\n", formatParams(scenario.Params))

		_, err := service.ParseRequest(scenario.Params, scenario.SortFields...)

		if err != nil {
			fmt.Printf("‚ùå Erro capturado: %v\n", err)

			// Formatar erro para API
			apiError := formatDomainError(err)
			jsonError, _ := json.MarshalIndent(apiError, "   ", "  ")
			fmt.Printf("üìã Resposta da API:\n   %s\n", string(jsonError))

			// Verificar se √© o erro esperado
			if strings.Contains(err.Error(), scenario.ExpectedErr) {
				fmt.Printf("‚úÖ Erro corresponde ao esperado: %s\n", scenario.ExpectedErr)
			} else {
				fmt.Printf("‚ö†Ô∏è  Erro diferente do esperado. Esperado: %s\n", scenario.ExpectedErr)
			}
		} else {
			fmt.Printf("‚ö†Ô∏è  Nenhum erro capturado (deveria ter falhado)\n")
		}
	}
}

func formatParams(params url.Values) string {
	var parts []string
	for key, values := range params {
		for _, value := range values {
			parts = append(parts, fmt.Sprintf("%s=%s", key, value))
		}
	}
	return strings.Join(parts, "&")
}

func demonstrateErrorRecovery() {
	fmt.Println("\n=== 2. Demonstra√ß√£o de Recupera√ß√£o de Erros ===")

	service := pagination.NewPaginationService(nil)

	// Cen√°rios de recupera√ß√£o graceful
	recoveryScenarios := []struct {
		name        string
		params      url.Values
		description string
	}{
		{
			name:        "Par√¢metros Vazios",
			params:      url.Values{},
			description: "Deve usar valores padr√£o quando nenhum par√¢metro √© fornecido",
		},
		{
			name: "P√°gina Ausente",
			params: url.Values{
				"limit": []string{"20"},
				"sort":  []string{"name"},
			},
			description: "Deve usar p√°gina 1 como padr√£o",
		},
		{
			name: "Limite Ausente",
			params: url.Values{
				"page": []string{"2"},
				"sort": []string{"name"},
			},
			description: "Deve usar limite padr√£o",
		},
		{
			name: "Ordena√ß√£o Ausente",
			params: url.Values{
				"page":  []string{"1"},
				"limit": []string{"10"},
			},
			description: "Deve usar ordena√ß√£o padr√£o",
		},
	}

	for i, scenario := range recoveryScenarios {
		fmt.Printf("\nüîÑ Teste de Recupera√ß√£o %d: %s\n", i+1, scenario.name)
		fmt.Printf("üìù %s\n", scenario.description)
		fmt.Printf("üîó Par√¢metros: %s\n", formatParams(scenario.params))

		result, err := service.ParseRequest(scenario.params, "id", "name", "email")

		if err != nil {
			fmt.Printf("‚ùå Erro inesperado: %v\n", err)
		} else {
			fmt.Printf("‚úÖ Recupera√ß√£o bem-sucedida:\n")
			fmt.Printf("   P√°gina: %d\n", result.Page)
			fmt.Printf("   Limite: %d\n", result.Limit)
			fmt.Printf("   Campo de ordena√ß√£o: %s\n", result.SortField)
			fmt.Printf("   Ordem: %s\n", result.SortOrder)
		}
	}
}

func demonstrateErrorChaining() {
	fmt.Println("\n=== 3. Demonstra√ß√£o de Encadeamento de Erros ===")

	service := pagination.NewPaginationService(nil)

	// Simular uma cadeia de opera√ß√µes que pode falhar
	operations := []struct {
		name   string
		params url.Values
		fields []string
	}{
		{
			name: "Parse de Par√¢metros",
			params: url.Values{
				"page":  []string{"abc"},
				"limit": []string{"10"},
			},
			fields: []string{"id", "name"},
		},
		{
			name: "Valida√ß√£o de Campos",
			params: url.Values{
				"page":  []string{"1"},
				"limit": []string{"10"},
				"sort":  []string{"password"},
			},
			fields: []string{"id", "name"},
		},
		{
			name: "Valida√ß√£o de Limites",
			params: url.Values{
				"page":  []string{"1"},
				"limit": []string{"1000"},
			},
			fields: []string{"id", "name"},
		},
	}

	for i, op := range operations {
		fmt.Printf("\nüîó Opera√ß√£o %d: %s\n", i+1, op.name)

		// Parse
		params, parseErr := service.ParseRequest(op.params, op.fields...)
		if parseErr != nil {
			fmt.Printf("‚ùå Falha no parse: %v\n", parseErr)

			// Demonstrar que mesmo com erro, podemos tentar opera√ß√µes subsequentes
			fmt.Printf("üîÑ Tentando construir query mesmo assim...\n")

			// Usar par√¢metros padr√£o para continuar
			defaultParams := url.Values{
				"page":  []string{"1"},
				"limit": []string{"10"},
			}
			fallbackParams, _ := service.ParseRequest(defaultParams, op.fields...)
			query := service.BuildQuery("SELECT * FROM users", fallbackParams)
			fmt.Printf("‚úÖ Query de fallback constru√≠da: %s\n", query)
			continue
		}

		// Construir query
		query := service.BuildQuery("SELECT * FROM users", params)
		fmt.Printf("‚úÖ Query constru√≠da: %s\n", query)

		// Validar p√°gina vs total de registros
		totalRecords := 100
		pageValidationErr := service.ValidatePageNumber(params, totalRecords)
		if pageValidationErr != nil {
			fmt.Printf("‚ùå Valida√ß√£o de p√°gina falhou: %v\n", pageValidationErr)
		} else {
			fmt.Printf("‚úÖ P√°gina v√°lida para %d registros\n", totalRecords)
		}
	}
}

func demonstrateUserFriendlyErrors() {
	fmt.Println("\n=== 4. Demonstra√ß√£o de Erros Amig√°veis ao Usu√°rio ===")

	service := pagination.NewPaginationService(nil)

	// Erros comuns com mensagens amig√°veis
	userScenarios := []struct {
		params      url.Values
		userMessage string
		devMessage  string
	}{
		{
			params:      url.Values{"page": []string{"0"}},
			userMessage: "A primeira p√°gina √© a n√∫mero 1. Tente novamente com page=1.",
			devMessage:  "Page parameter must be >= 1",
		},
		{
			params:      url.Values{"limit": []string{"1000"}},
			userMessage: "Muitos resultados solicitados. O m√°ximo permitido √© 100 registros por p√°gina.",
			devMessage:  "Limit exceeds maximum allowed value",
		},
		{
			params:      url.Values{"sort": []string{"password"}},
			userMessage: "N√£o √© poss√≠vel ordenar por este campo. Campos dispon√≠veis: id, name, email.",
			devMessage:  "Sort field not in allowed list",
		},
		{
			params:      url.Values{"order": []string{"random"}},
			userMessage: "Ordena√ß√£o deve ser 'crescente' (asc) ou 'decrescente' (desc).",
			devMessage:  "Invalid sort order value",
		},
	}

	for i, scenario := range userScenarios {
		fmt.Printf("\nüë§ Cen√°rio de Usu√°rio %d:\n", i+1)
		fmt.Printf("üîó Par√¢metros: %s\n", formatParams(scenario.params))

		_, err := service.ParseRequest(scenario.params, "id", "name", "email")

		if err != nil {
			fmt.Printf("üîß Erro t√©cnico: %v\n", err)
			fmt.Printf("üì± Mensagem para usu√°rio: %s\n", scenario.userMessage)
			fmt.Printf("üõ†Ô∏è  Mensagem para desenvolvedor: %s\n", scenario.devMessage)

			// Sugerir corre√ß√£o autom√°tica
			correction := suggestCorrection(scenario.params)
			if correction != "" {
				fmt.Printf("üí° Sugest√£o de corre√ß√£o: %s\n", correction)
			}
		}
	}
}

func suggestCorrection(params url.Values) string {
	corrections := []string{}

	if page := params.Get("page"); page != "" {
		if pageNum, err := strconv.Atoi(page); err != nil || pageNum <= 0 {
			corrections = append(corrections, "page=1")
		}
	}

	if limit := params.Get("limit"); limit != "" {
		if limitNum, err := strconv.Atoi(limit); err != nil || limitNum <= 0 {
			corrections = append(corrections, "limit=10")
		} else if limitNum > 100 {
			corrections = append(corrections, "limit=100")
		}
	}

	if sort := params.Get("sort"); sort != "" {
		validFields := []string{"id", "name", "email"}
		valid := false
		for _, field := range validFields {
			if sort == field {
				valid = true
				break
			}
		}
		if !valid {
			corrections = append(corrections, "sort=id")
		}
	}

	if order := params.Get("order"); order != "" {
		if order != "asc" && order != "desc" {
			corrections = append(corrections, "order=asc")
		}
	}

	if len(corrections) > 0 {
		return strings.Join(corrections, "&")
	}

	return ""
}

func main() {
	fmt.Println("‚ùå Exemplos de Tratamento de Erros - M√≥dulo de Pagina√ß√£o")
	fmt.Println("========================================================")
	fmt.Println()

	// Executar todas as demonstra√ß√µes
	demonstrateErrorScenarios()
	demonstrateErrorRecovery()
	demonstrateErrorChaining()
	demonstrateUserFriendlyErrors()

	fmt.Println("\nüéâ Todos os exemplos de tratamento de erros foram executados!")
	fmt.Println()
	fmt.Println("üí° Principais aprendizados:")
	fmt.Println("   ‚Ä¢ Erros s√£o detectados e classificados automaticamente")
	fmt.Println("   ‚Ä¢ Domain errors fornecem c√≥digos estruturados")
	fmt.Println("   ‚Ä¢ Recupera√ß√£o graceful com valores padr√£o")
	fmt.Println("   ‚Ä¢ Mensagens amig√°veis para usu√°rios finais")
	fmt.Println("   ‚Ä¢ Sugest√µes autom√°ticas de corre√ß√£o")
	fmt.Println("   ‚Ä¢ Encadeamento de opera√ß√µes com fallbacks")
}
