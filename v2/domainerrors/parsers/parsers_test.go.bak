package parsers

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"errors"
	"fmt"
	"net"
	"net/url"
	"testing"

	"github.com/fsvxavier/nexs-lib/v2/domainerrors/interfaces"
	"github.com/fsvxavier/nexs-lib/v2/domainerrors/types"
)

// TestDistributedParserRegistry testa o registry distribuído.
func TestDistributedParserRegistry(t *testing.T) {
	registry := NewDistributedParserRegistry()

	// Testa listagem de parsers padrão
	parsers := registry.ListParsers()
	if len(parsers) == 0 {
		t.Error("Expected default parsers to be registered")
	}

	// Verifica se parsers específicos estão registrados
	expectedParsers := []string{"postgresql", "pgx", "grpc", "http", "redis", "mongodb", "aws"}
	for _, expected := range expectedParsers {
		if _, exists := parsers[expected]; !exists {
			t.Errorf("Expected parser %s to be registered", expected)
		}
	}
}

// TestGRPCErrorParser testa o parser gRPC.
func TestGRPCErrorParser(t *testing.T) {
	parser := NewGRPCErrorParser()

	tests := []struct {
		name     string
		err      error
		canParse bool
		code     string
	}{
		{
			name:     "gRPC status error",
			err:      errors.New("rpc error: code = NotFound desc = user not found"),
			canParse: true,
			code:     "GRPC_UNKNOWN", // Fallback since we don't have real gRPC status
		},
		{
			name:     "HTTP error",
			err:      errors.New("http connection failed"),
			canParse: false,
		},
		{
			name:     "nil error",
			err:      nil,
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code == "" {
					t.Error("Expected code to be set")
				}
			}
		})
	}
}

// TestHTTPErrorParser testa o parser HTTP.
func TestHTTPErrorParser(t *testing.T) {
	parser := NewHTTPErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
	}{
		{
			name:         "HTTP status 404",
			err:          fmt.Errorf("http: status 404 Not Found"),
			canParse:     true,
			expectedCode: "HTTP_404",
		},
		{
			name:         "HTTP connection error",
			err:          fmt.Errorf("http: connection refused"),
			canParse:     true,
			expectedCode: "HTTP_UNKNOWN",
		},
		{
			name:     "Non-HTTP error",
			err:      fmt.Errorf("database error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
			}
		})
	}
}

// TestRedisErrorParser testa o parser Redis.
func TestRedisErrorParser(t *testing.T) {
	parser := NewRedisErrorParser()

	tests := []struct {
		name     string
		err      error
		canParse bool
	}{
		{
			name:     "Redis connection error",
			err:      fmt.Errorf("redis: connection refused"),
			canParse: true,
		},
		{
			name:     "Redis timeout",
			err:      fmt.Errorf("redis: operation timeout"),
			canParse: true,
		},
		{
			name:     "Non-Redis error",
			err:      fmt.Errorf("mysql error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}
		})
	}
}

// TestMongoDBErrorParser testa o parser MongoDB.
func TestMongoDBErrorParser(t *testing.T) {
	parser := NewMongoDBErrorParser()

	tests := []struct {
		name     string
		err      error
		canParse bool
	}{
		{
			name:     "MongoDB duplicate key",
			err:      fmt.Errorf("mongo: duplicate key error"),
			canParse: true,
		},
		{
			name:     "MongoDB timeout",
			err:      fmt.Errorf("mongodb: connection timeout"),
			canParse: true,
		},
		{
			name:     "Non-MongoDB error",
			err:      fmt.Errorf("postgres error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}
		})
	}
}

// TestAWSErrorParser testa o parser AWS.
func TestAWSErrorParser(t *testing.T) {
	parser := NewAWSErrorParser()

	tests := []struct {
		name     string
		err      error
		canParse bool
	}{
		{
			name:     "AWS access denied",
			err:      fmt.Errorf("aws: AccessDenied"),
			canParse: true,
		},
		{
			name:     "AWS throttling",
			err:      fmt.Errorf("aws: ThrottlingException"),
			canParse: true,
		},
		{
			name:     "Non-AWS error",
			err:      fmt.Errorf("generic error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}
		})
	}
}

// TestPGXErrorParser testa o parser PGX.
func TestPGXErrorParser(t *testing.T) {
	parser := NewPGXErrorParser()

	tests := []struct {
		name     string
		err      error
		canParse bool
	}{
		{
			name:     "PGX connection error",
			err:      fmt.Errorf("pgx: connection failed"),
			canParse: true,
		},
		{
			name:     "PGX query error",
			err:      fmt.Errorf("pgx: query failed"),
			canParse: true,
		},
		{
			name:     "Non-PGX error",
			err:      fmt.Errorf("mysql error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}
		})
	}
}

// TestGenericDatabasePlugin testa o plugin genérico.
func TestGenericDatabasePlugin(t *testing.T) {
	plugin := NewGenericDatabasePlugin()

	// Testa configuração padrão
	defaultConfig := plugin.DefaultConfig()
	if err := plugin.ValidateConfig(defaultConfig); err != nil {
		t.Errorf("Default config should be valid: %v", err)
	}

	// Cria parser com configuração padrão
	parser, err := plugin.CreateParser(defaultConfig)
	if err != nil {
		t.Errorf("Failed to create parser: %v", err)
	}

	// Testa parsing com timeout específico
	dbErr := errors.New("database operation timeout")
	if !parser.CanParse(dbErr) {
		t.Error("Parser should be able to parse database error")
	}

	parsed := parser.Parse(dbErr)
	if parsed.Code != "DB_TIMEOUT" {
		t.Errorf("Expected code DB_TIMEOUT, got %s", parsed.Code)
	}
}

// TestCustomParserFactory testa a factory customizada.
func TestCustomParserFactory(t *testing.T) {
	factory := NewCustomParserFactory()

	// Testa regex matcher
	config := map[string]interface{}{
		"pattern":    `error code: (\d+)`,
		"error_code": "CUSTOM_ERROR",
	}

	parser, err := factory.CreateParser("regex_matcher", config)
	if err != nil {
		t.Errorf("Failed to create regex parser: %v", err)
	}

	testErr := errors.New("error code: 12345")
	if !parser.CanParse(testErr) {
		t.Error("Regex parser should match the error")
	}

	parsed := parser.Parse(testErr)
	if parsed.Code != "CUSTOM_ERROR" {
		t.Errorf("Expected CUSTOM_ERROR, got %s", parsed.Code)
	}

	// Testa keyword matcher
	keywordConfig := map[string]interface{}{
		"keywords":   []interface{}{"timeout", "connection"},
		"error_code": "NETWORK_ERROR",
	}

	keywordParser, err := factory.CreateParser("keyword_matcher", keywordConfig)
	if err != nil {
		t.Errorf("Failed to create keyword parser: %v", err)
	}

	timeoutErr := errors.New("connection timeout occurred")
	if !keywordParser.CanParse(timeoutErr) {
		t.Error("Keyword parser should match the error")
	}

	keywordParsed := keywordParser.Parse(timeoutErr)
	if keywordParsed.Code != "NETWORK_ERROR" {
		t.Errorf("Expected NETWORK_ERROR, got %s", keywordParsed.Code)
	}
}

// TestDistributedRegistryParsing testa o parsing distribuído.
func TestDistributedRegistryParsing(t *testing.T) {
	registry := NewDistributedParserRegistry()
	ctx := context.Background()

	tests := []struct {
		name          string
		err           error
		expectedCode  string
		shouldSucceed bool
	}{
		{
			name:          "Redis error",
			err:           errors.New("redis: connection timeout"),
			expectedCode:  "REDIS_TIMEOUT",
			shouldSucceed: true,
		},
		{
			name:          "HTTP error",
			err:           errors.New("404 Not Found"),
			expectedCode:  "HTTP_404",
			shouldSucceed: true,
		},
		{
			name:          "MongoDB error",
			err:           errors.New("duplicate key error (11000)"),
			expectedCode:  "MONGO_DUPLICATE_KEY",
			shouldSucceed: true,
		},
		{
			name:          "Unknown error",
			err:           errors.New("unknown system error"),
			shouldSucceed: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			parsed, parserName, err := registry.Parse(ctx, tt.err)

			if tt.shouldSucceed {
				if err != nil {
					t.Errorf("Expected parsing to succeed, got error: %v", err)
				}
				if parsed == nil {
					t.Error("Expected parsed result to be non-nil")
				}
				if parsed != nil && parsed.Code != tt.expectedCode {
					t.Errorf("Expected code %s, got %s", tt.expectedCode, parsed.Code)
				}
				if parserName == "" {
					t.Error("Expected parser name to be set")
				}
			} else {
				if err == nil {
					t.Error("Expected parsing to fail")
				}
			}
		})
	}
}

// TestParserPriority testa a prioridade dos parsers.
func TestParserPriority(t *testing.T) {
	registry := NewDistributedParserRegistry()

	// Registra um parser customizado com prioridade alta
	customParser := &KeywordMatcherParser{
		keywords:  []string{"test"},
		errorCode: "HIGH_PRIORITY_ERROR",
	}

	err := registry.RegisterParser("high_priority", customParser, 200)
	if err != nil {
		t.Errorf("Failed to register custom parser: %v", err)
	}

	// Testa que o parser de alta prioridade é usado
	testErr := errors.New("test error message")
	ctx := context.Background()

	parsed, parserName, err := registry.Parse(ctx, testErr)
	if err != nil {
		t.Errorf("Parsing failed: %v", err)
	}

	if parserName != "high_priority" {
		t.Errorf("Expected high_priority parser to be used, got %s", parserName)
	}

	if parsed.Code != "HIGH_PRIORITY_ERROR" {
		t.Errorf("Expected HIGH_PRIORITY_ERROR, got %s", parsed.Code)
	}
}

// TestPluginRegistration testa o registro de plugins.
func TestPluginRegistration(t *testing.T) {
	registry := NewDistributedParserRegistry()
	plugin := NewGenericDatabasePlugin()

	// Registra plugin
	err := registry.RegisterPlugin(plugin)
	if err != nil {
		t.Errorf("Failed to register plugin: %v", err)
	}

	// Verifica se parser foi criado
	parsers := registry.ListParsers()
	if !parsers[plugin.Name()] {
		t.Error("Plugin parser should be enabled")
	}

	// Testa reconfiguração
	newConfig := map[string]interface{}{
		"patterns": []interface{}{"custom_pattern"},
		"error_codes": map[string]interface{}{
			"custom": "CUSTOM_DB_ERROR",
		},
	}

	err = registry.ConfigureParser(plugin.Name(), newConfig)
	if err != nil {
		t.Errorf("Failed to reconfigure parser: %v", err)
	}

	// Verifica configuração
	config, err := registry.GetConfiguration(plugin.Name())
	if err != nil {
		t.Errorf("Failed to get configuration: %v", err)
	}

	patterns, ok := config["patterns"].([]interface{})
	if !ok || len(patterns) != 1 || patterns[0] != "custom_pattern" {
		t.Error("Configuration was not updated correctly")
	}
}

// TestPostgreSQLErrorParser testa o parser PostgreSQL
func TestPostgreSQLErrorParser(t *testing.T) {
	parser := NewPostgreSQLErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
		expectedType string
	}{
		{
			name:         "PostgreSQL SQLSTATE error",
			err:          fmt.Errorf("pq: duplicate key value violates unique constraint (SQLSTATE 23505)"),
			canParse:     true,
			expectedCode: "DB_23505",
			expectedType: string(types.ErrorTypeDatabase),
		},
		{
			name:         "PostgreSQL with postgres in message",
			err:          fmt.Errorf("postgres connection failed"),
			canParse:     true,
			expectedCode: "DB_UNKNOWN",
			expectedType: string(types.ErrorTypeDatabase),
		},
		{
			name:     "Non-PostgreSQL error",
			err:      fmt.Errorf("redis connection failed"),
			canParse: false,
		},
		{
			name:     "Nil error",
			err:      nil,
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse && tt.err != nil {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
				if parsed.Type != tt.expectedType {
					t.Errorf("Parse().Type = %v, want %v", parsed.Type, tt.expectedType)
				}
			}
		})
	}
}

// TestMySQLErrorParser testa o parser MySQL completo
func TestMySQLErrorParser(t *testing.T) {
	parser := NewMySQLErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
		retryable    bool
	}{
		{
			name:         "MySQL Error with code",
			err:          fmt.Errorf("Error 1040: Too many connections"),
			canParse:     true,
			expectedCode: "MYSQL_1040",
			retryable:    true,
		},
		{
			name:         "MySQL Error 1205",
			err:          fmt.Errorf("Error 1205: Lock wait timeout exceeded"),
			canParse:     true,
			expectedCode: "MYSQL_1205",
			retryable:    true,
		},
		{
			name:         "MySQL connection error",
			err:          fmt.Errorf("Error 2003: Can't connect to MySQL server"),
			canParse:     true,
			expectedCode: "MYSQL_2003",
			retryable:    true,
		},
		{
			name:         "MySQL error without pattern",
			err:          fmt.Errorf("mysql: connection failed"),
			canParse:     true,
			expectedCode: "MYSQL_UNKNOWN",
			retryable:    false,
		},
		{
			name:     "Non-MySQL error",
			err:      fmt.Errorf("redis connection failed"),
			canParse: false,
		},
		{
			name:     "Nil error",
			err:      nil,
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse && tt.err != nil {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
				if parsed.Retryable != tt.retryable {
					t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
				}
				if parsed.Details["database_type"] != "mysql" {
					t.Error("Expected database_type to be mysql")
				}
			}
		})
	}
}

// TestNetworkErrorParser testa o parser de erros de rede
func TestNetworkErrorParser(t *testing.T) {
	parser := NewNetworkErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
		retryable    bool
	}{
		{
			name:         "Connection refused",
			err:          fmt.Errorf("dial tcp 127.0.0.1:5432: connect: connection refused"),
			canParse:     true,
			expectedCode: "NETWORK_CONNECTION_REFUSED",
			retryable:    true,
		},
		{
			name:         "DNS lookup failed",
			err:          fmt.Errorf("dial tcp: lookup example.com: no such host"),
			canParse:     true,
			expectedCode: "NETWORK_DNS_ERROR",
			retryable:    true,
		},
		{
			name:         "Generic network error",
			err:          fmt.Errorf("network is unreachable"),
			canParse:     true,
			expectedCode: "NETWORK_UNREACHABLE",
			retryable:    true,
		},
		{
			name:         "URL error",
			err:          &url.Error{Op: "Get", URL: "http://example.com", Err: fmt.Errorf("connection timeout")},
			canParse:     true,
			expectedCode: "NETWORK_URL_ERROR",
			retryable:    true,
		},
		{
			name:         "Net error interface",
			err:          &net.OpError{Op: "dial", Net: "tcp", Addr: nil, Err: fmt.Errorf("connection refused")},
			canParse:     true,
			expectedCode: "NETWORK_OP_ERROR",
			retryable:    true,
		},
		{
			name:     "Non-network error",
			err:      fmt.Errorf("database error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
				if parsed.Retryable != tt.retryable {
					t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
				}
			}
		})
	}
}

// TestTimeoutErrorParser testa o parser de erros de timeout
func TestTimeoutErrorParser(t *testing.T) {
	parser := NewTimeoutErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
		retryable    bool
	}{
		{
			name:         "Context timeout",
			err:          context.DeadlineExceeded,
			canParse:     true,
			expectedCode: "TIMEOUT_CONTEXT_DEADLINE",
			retryable:    true,
		},
		{
			name:         "Context canceled",
			err:          context.Canceled,
			canParse:     true,
			expectedCode: "TIMEOUT_CONTEXT_CANCELED",
			retryable:    false,
		},
		{
			name:         "Connection timeout",
			err:          fmt.Errorf("connection timeout"),
			canParse:     true,
			expectedCode: "TIMEOUT_CONNECTION",
			retryable:    true,
		},
		{
			name:         "Read timeout",
			err:          fmt.Errorf("read timeout"),
			canParse:     true,
			expectedCode: "TIMEOUT_READ",
			retryable:    true,
		},
		{
			name:         "Write timeout",
			err:          fmt.Errorf("write timeout"),
			canParse:     true,
			expectedCode: "TIMEOUT_WRITE",
			retryable:    true,
		},
		{
			name:         "Operation timeout",
			err:          fmt.Errorf("operation timed out"),
			canParse:     true,
			expectedCode: "TIMEOUT_OPERATION",
			retryable:    true,
		},
		{
			name:     "Non-timeout error",
			err:      fmt.Errorf("validation error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
				if parsed.Retryable != tt.retryable {
					t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
				}
			}
		})
	}
}

// TestSQLErrorParser testa o parser SQL genérico
func TestSQLErrorParser(t *testing.T) {
	parser := NewSQLErrorParser()

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
	}{
		{
			name:         "sql.ErrNoRows",
			err:          sql.ErrNoRows,
			canParse:     true,
			expectedCode: "SQL_NO_ROWS",
		},
		{
			name:         "sql.ErrTxDone",
			err:          sql.ErrTxDone,
			canParse:     true,
			expectedCode: "SQL_TX_DONE",
		},
		{
			name:         "sql.ErrConnDone",
			err:          sql.ErrConnDone,
			canParse:     true,
			expectedCode: "SQL_CONN_DONE",
		},
		{
			name:         "driver.ErrSkip",
			err:          driver.ErrSkip,
			canParse:     true,
			expectedCode: "SQL_DRIVER_SKIP",
		},
		{
			name:         "driver.ErrBadConn",
			err:          driver.ErrBadConn,
			canParse:     true,
			expectedCode: "SQL_BAD_CONN",
		},
		{
			name:         "Generic SQL error",
			err:          fmt.Errorf("sql: database is locked"),
			canParse:     true,
			expectedCode: "SQL_GENERIC",
		},
		{
			name:     "Non-SQL error",
			err:      fmt.Errorf("http error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
			}
		})
	}
}

// TestCompositeErrorParser testa o parser composto
func TestCompositeErrorParser(t *testing.T) {
	pgParser := NewPostgreSQLErrorParser()
	httpParser := NewHTTPErrorParser()

	composite := NewCompositeErrorParser(pgParser, httpParser)

	tests := []struct {
		name         string
		err          error
		canParse     bool
		expectedCode string
	}{
		{
			name:         "PostgreSQL error",
			err:          fmt.Errorf("pq: duplicate key (SQLSTATE 23505)"),
			canParse:     true,
			expectedCode: "DB_23505",
		},
		{
			name:         "HTTP error",
			err:          fmt.Errorf("http: status 404 Not Found"),
			canParse:     true,
			expectedCode: "HTTP_404",
		},
		{
			name:     "Unknown error",
			err:      fmt.Errorf("unknown system error"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := composite.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := composite.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
			}
		})
	}
}

// TestDefaultParser testa o parser padrão
func TestDefaultParser(t *testing.T) {
	parser := NewDefaultParser()

	// Testa parsing de diferentes tipos de erro
	errors := []error{
		fmt.Errorf("database connection failed"),
		fmt.Errorf("network timeout"),
		fmt.Errorf("validation error: field required"),
		fmt.Errorf("unknown error"),
	}

	for _, err := range errors {
		parsed := ParseError(err, parser)
		if parsed.Code == "" {
			t.Errorf("ParseError should always set a code")
		}
		if parsed.Type == "" {
			t.Errorf("ParseError should always set a type")
		}
	}
}

// TestPostgreSQLParserAdvanced testa casos avançados do PostgreSQL parser
func TestPostgreSQLParserAdvanced(t *testing.T) {
	parser := NewPostgreSQLErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
		message      string
	}{
		{
			name:         "Unique constraint violation",
			err:          fmt.Errorf("pq: duplicate key value violates unique constraint \"users_email_key\" (SQLSTATE 23505)"),
			expectedCode: "DB_23505",
			retryable:    false,
			message:      "Unique constraint violation",
		},
		{
			name:         "Foreign key violation",
			err:          fmt.Errorf("pq: insert or update on table violates foreign key constraint (SQLSTATE 23503)"),
			expectedCode: "DB_23503",
			retryable:    false,
			message:      "Foreign key constraint violation",
		},
		{
			name:         "Connection failure",
			err:          fmt.Errorf("pq: connection to server was lost (SQLSTATE 08006)"),
			expectedCode: "DB_08006",
			retryable:    true,
			message:      "Connection failure",
		},
		{
			name:         "Serialization failure",
			err:          fmt.Errorf("pq: could not serialize access (SQLSTATE 40001)"),
			expectedCode: "DB_40001",
			retryable:    true,
			message:      "Database error (SQLSTATE 40001)",
		},
		{
			name:         "Too many connections",
			err:          fmt.Errorf("pq: sorry, too many clients already (SQLSTATE 53300)"),
			expectedCode: "DB_53300",
			retryable:    true,
			message:      "Too many connections",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			parsed := parser.Parse(tt.err)

			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Message != tt.message {
				t.Errorf("Parse().Message = %v, want %v", parsed.Message, tt.message)
			}
			if parsed.Details["database_type"] != "postgresql" {
				t.Error("Expected database_type to be postgresql")
			}
		})
	}
}

// TestRedisErrorParserAdvanced testa casos avançados do Redis
func TestRedisErrorParserAdvanced(t *testing.T) {
	parser := NewRedisErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "Redis connection timeout",
			err:          fmt.Errorf("redis: dial tcp 127.0.0.1:6379: i/o timeout"),
			expectedCode: "REDIS_TIMEOUT",
			retryable:    true,
		},
		{
			name:         "Redis connection refused",
			err:          fmt.Errorf("redis: dial tcp 127.0.0.1:6379: connect: connection refused"),
			expectedCode: "REDIS_CONNECTION_REFUSED",
			retryable:    true,
		},
		{
			name:         "Redis authentication failed",
			err:          fmt.Errorf("redis: NOAUTH Authentication required"),
			expectedCode: "REDIS_AUTH_FAILED",
			retryable:    false,
		},
		{
			name:         "Redis max clients reached",
			err:          fmt.Errorf("redis: ERR max number of clients reached"),
			expectedCode: "REDIS_MAX_CLIENTS",
			retryable:    true,
		},
		{
			name:         "Redis out of memory",
			err:          fmt.Errorf("redis: OOM command not allowed when used memory > 'maxmemory'"),
			expectedCode: "REDIS_OUT_OF_MEMORY",
			retryable:    true,
		},
		{
			name:         "Redis readonly slave",
			err:          fmt.Errorf("redis: READONLY You can't write against a read only slave"),
			expectedCode: "REDIS_READONLY",
			retryable:    false,
		},
		{
			name:         "Redis key not found",
			err:          fmt.Errorf("redis: nil"),
			expectedCode: "REDIS_NIL",
			retryable:    false,
		},
		{
			name:         "Redis generic error",
			err:          fmt.Errorf("redis: something went wrong"),
			expectedCode: "REDIS_UNKNOWN",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse Redis error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["database_type"] != "redis" {
				t.Error("Expected database_type to be redis")
			}
		})
	}
}

// TestMongoDBErrorParserAdvanced testa casos avançados do MongoDB
func TestMongoDBErrorParserAdvanced(t *testing.T) {
	parser := NewMongoDBErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "MongoDB duplicate key error",
			err:          fmt.Errorf("mongo: E11000 duplicate key error collection"),
			expectedCode: "MONGO_DUPLICATE_KEY",
			retryable:    false,
		},
		{
			name:         "MongoDB connection timeout",
			err:          fmt.Errorf("mongo: no reachable servers"),
			expectedCode: "MONGO_CONNECTION_TIMEOUT",
			retryable:    true,
		},
		{
			name:         "MongoDB authentication failed",
			err:          fmt.Errorf("mongo: auth failed"),
			expectedCode: "MONGO_AUTH_FAILED",
			retryable:    false,
		},
		{
			name:         "MongoDB write concern error",
			err:          fmt.Errorf("mongo: write concern error"),
			expectedCode: "MONGO_WRITE_CONCERN_ERROR",
			retryable:    true,
		},
		{
			name:         "MongoDB cursor not found",
			err:          fmt.Errorf("mongo: cursor 123 not found"),
			expectedCode: "MONGO_CURSOR_NOT_FOUND",
			retryable:    false,
		},
		{
			name:         "MongoDB exceeded time limit",
			err:          fmt.Errorf("mongo: operation exceeded time limit"),
			expectedCode: "MONGO_TIMEOUT",
			retryable:    true,
		},
		{
			name:         "MongoDB network error",
			err:          fmt.Errorf("mongodb: dial tcp: connect: connection refused"),
			expectedCode: "MONGO_NETWORK_ERROR",
			retryable:    true,
		},
		{
			name:         "MongoDB generic error",
			err:          fmt.Errorf("mongo: unknown error occurred"),
			expectedCode: "MONGO_UNKNOWN",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse MongoDB error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["database_type"] != "mongodb" {
				t.Error("Expected database_type to be mongodb")
			}
		})
	}
}

// TestAWSErrorParserAdvanced testa casos avançados do AWS
func TestAWSErrorParserAdvanced(t *testing.T) {
	parser := NewAWSErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "AWS AccessDenied",
			err:          fmt.Errorf("aws: AccessDenied: User not authorized"),
			expectedCode: "AWS_ACCESS_DENIED",
			retryable:    false,
		},
		{
			name:         "AWS ThrottlingException",
			err:          fmt.Errorf("aws: ThrottlingException: Rate exceeded"),
			expectedCode: "AWS_THROTTLING",
			retryable:    true,
		},
		{
			name:         "AWS RequestTimeout",
			err:          fmt.Errorf("aws: RequestTimeout: Request timed out"),
			expectedCode: "AWS_REQUEST_TIMEOUT",
			retryable:    true,
		},
		{
			name:         "AWS ServiceUnavailable",
			err:          fmt.Errorf("aws: ServiceUnavailable: Service temporarily unavailable"),
			expectedCode: "AWS_SERVICE_UNAVAILABLE",
			retryable:    true,
		},
		{
			name:         "AWS InternalError",
			err:          fmt.Errorf("aws: InternalError: We encountered an internal error"),
			expectedCode: "AWS_INTERNAL_ERROR",
			retryable:    true,
		},
		{
			name:         "AWS InvalidParameterValue",
			err:          fmt.Errorf("aws: InvalidParameterValue: Parameter value is invalid"),
			expectedCode: "AWS_INVALID_PARAMETER",
			retryable:    false,
		},
		{
			name:         "AWS ResourceNotFound",
			err:          fmt.Errorf("aws: ResourceNotFound: The requested resource was not found"),
			expectedCode: "AWS_RESOURCE_NOT_FOUND",
			retryable:    false,
		},
		{
			name:         "AWS LimitExceeded",
			err:          fmt.Errorf("aws: LimitExceeded: Request limit exceeded"),
			expectedCode: "AWS_LIMIT_EXCEEDED",
			retryable:    true,
		},
		{
			name:         "AWS generic error",
			err:          fmt.Errorf("aws: UnknownError: Something went wrong"),
			expectedCode: "AWS_UNKNOWN",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse AWS error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["cloud_provider"] != "aws" {
				t.Error("Expected cloud_provider to be aws")
			}
		})
	}
}

// TestPGXErrorParserAdvanced testa casos avançados do PGX
func TestPGXErrorParserAdvanced(t *testing.T) {
	parser := NewPGXErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "PGX connection failed",
			err:          fmt.Errorf("pgx: failed to connect to database"),
			expectedCode: "PGX_CONNECTION_FAILED",
			retryable:    true,
		},
		{
			name:         "PGX query execution failed",
			err:          fmt.Errorf("pgx: query execution failed"),
			expectedCode: "PGX_QUERY_FAILED",
			retryable:    false,
		},
		{
			name:         "PGX transaction failed",
			err:          fmt.Errorf("pgx: transaction failed"),
			expectedCode: "PGX_TRANSACTION_FAILED",
			retryable:    true,
		},
		{
			name:         "PGX connection timeout",
			err:          fmt.Errorf("pgx: dial timeout"),
			expectedCode: "PGX_TIMEOUT",
			retryable:    true,
		},
		{
			name:         "PGX authentication failed",
			err:          fmt.Errorf("pgx: password authentication failed"),
			expectedCode: "PGX_AUTH_FAILED",
			retryable:    false,
		},
		{
			name:         "PGX generic error",
			err:          fmt.Errorf("pgx: unknown error"),
			expectedCode: "PGX_UNKNOWN",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse PGX error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["driver_type"] != "pgx" {
				t.Error("Expected driver_type to be pgx")
			}
		})
	}
}

// TestGRPCErrorParserAdvanced testa casos avançados do gRPC
func TestGRPCErrorParserAdvanced(t *testing.T) {
	parser := NewGRPCErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "gRPC NotFound",
			err:          fmt.Errorf("rpc error: code = NotFound desc = user not found"),
			expectedCode: "GRPC_NOT_FOUND",
			retryable:    false,
		},
		{
			name:         "gRPC Unavailable",
			err:          fmt.Errorf("rpc error: code = Unavailable desc = service unavailable"),
			expectedCode: "GRPC_UNAVAILABLE",
			retryable:    true,
		},
		{
			name:         "gRPC DeadlineExceeded",
			err:          fmt.Errorf("rpc error: code = DeadlineExceeded desc = deadline exceeded"),
			expectedCode: "GRPC_DEADLINE_EXCEEDED",
			retryable:    true,
		},
		{
			name:         "gRPC PermissionDenied",
			err:          fmt.Errorf("rpc error: code = PermissionDenied desc = access denied"),
			expectedCode: "GRPC_PERMISSION_DENIED",
			retryable:    false,
		},
		{
			name:         "gRPC ResourceExhausted",
			err:          fmt.Errorf("rpc error: code = ResourceExhausted desc = quota exceeded"),
			expectedCode: "GRPC_RESOURCE_EXHAUSTED",
			retryable:    true,
		},
		{
			name:         "gRPC InvalidArgument",
			err:          fmt.Errorf("rpc error: code = InvalidArgument desc = invalid request"),
			expectedCode: "GRPC_INVALID_ARGUMENT",
			retryable:    false,
		},
		{
			name:         "gRPC Internal",
			err:          fmt.Errorf("rpc error: code = Internal desc = internal server error"),
			expectedCode: "GRPC_INTERNAL",
			retryable:    true,
		},
		{
			name:         "gRPC generic error",
			err:          fmt.Errorf("grpc: connection failed"),
			expectedCode: "GRPC_UNKNOWN",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse gRPC error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["protocol_type"] != "grpc" {
				t.Error("Expected protocol_type to be grpc")
			}
		})
	}
}

// TestHTTPErrorParserAdvanced testa casos avançados do HTTP
func TestHTTPErrorParserAdvanced(t *testing.T) {
	parser := NewHTTPErrorParser()

	tests := []struct {
		name         string
		err          error
		expectedCode string
		retryable    bool
	}{
		{
			name:         "HTTP 429 Too Many Requests",
			err:          fmt.Errorf("http: status 429 Too Many Requests"),
			expectedCode: "HTTP_429",
			retryable:    true,
		},
		{
			name:         "HTTP 500 Internal Server Error",
			err:          fmt.Errorf("http: status 500 Internal Server Error"),
			expectedCode: "HTTP_500",
			retryable:    true,
		},
		{
			name:         "HTTP 502 Bad Gateway",
			err:          fmt.Errorf("http: status 502 Bad Gateway"),
			expectedCode: "HTTP_502",
			retryable:    true,
		},
		{
			name:         "HTTP 503 Service Unavailable",
			err:          fmt.Errorf("http: status 503 Service Unavailable"),
			expectedCode: "HTTP_503",
			retryable:    true,
		},
		{
			name:         "HTTP 504 Gateway Timeout",
			err:          fmt.Errorf("http: status 504 Gateway Timeout"),
			expectedCode: "HTTP_504",
			retryable:    true,
		},
		{
			name:         "HTTP 401 Unauthorized",
			err:          fmt.Errorf("http: status 401 Unauthorized"),
			expectedCode: "HTTP_401",
			retryable:    false,
		},
		{
			name:         "HTTP 403 Forbidden",
			err:          fmt.Errorf("http: status 403 Forbidden"),
			expectedCode: "HTTP_403",
			retryable:    false,
		},
		{
			name:         "HTTP 400 Bad Request",
			err:          fmt.Errorf("http: status 400 Bad Request"),
			expectedCode: "HTTP_400",
			retryable:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if !parser.CanParse(tt.err) {
				t.Error("Parser should be able to parse HTTP error")
			}

			parsed := parser.Parse(tt.err)
			if parsed.Code != tt.expectedCode {
				t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
			}
			if parsed.Retryable != tt.retryable {
				t.Errorf("Parse().Retryable = %v, want %v", parsed.Retryable, tt.retryable)
			}
			if parsed.Details["protocol_type"] != "http" {
				t.Error("Expected protocol_type to be http")
			}
		})
	}
}

// BenchmarkDistributedParserRegistry testa performance do registry
func BenchmarkDistributedParserRegistry(b *testing.B) {
	registry := NewDistributedParserRegistry()
	ctx := context.Background()
	err := fmt.Errorf("pq: connection failed")
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, _, _ = registry.Parse(ctx, err)
	}
}

// BenchmarkPostgreSQLParser testa performance do parser PostgreSQL
func BenchmarkPostgreSQLParser(b *testing.B) {
	parser := NewPostgreSQLErrorParser()
	err := fmt.Errorf("pq: duplicate key value violates unique constraint (SQLSTATE 23505)")
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_ = parser.Parse(err)
	}
}

// TestDistributedRegistryAdvancedFeatures testa funcionalidades avançadas do registry
func TestDistributedRegistryAdvancedFeatures(t *testing.T) {
	registry := NewDistributedParserRegistry()

	// Testa EnableParser e DisableParser
	t.Run("EnableDisableParser", func(t *testing.T) {
		// Desabilita parser redis
		err := registry.DisableParser("redis")
		if err != nil {
			t.Errorf("Failed to disable parser: %v", err)
		}

		// Verifica se foi desabilitado
		parsers := registry.ListParsers()
		if parsers["redis"] {
			t.Error("Redis parser should be disabled")
		}

		// Reabilita parser redis
		err = registry.EnableParser("redis")
		if err != nil {
			t.Errorf("Failed to enable parser: %v", err)
		}

		// Verifica se foi reabilitado
		parsers = registry.ListParsers()
		if !parsers["redis"] {
			t.Error("Redis parser should be enabled")
		}
	})

	// Testa SetPriority
	t.Run("SetPriority", func(t *testing.T) {
		err := registry.SetPriority("redis", 500)
		if err != nil {
			t.Errorf("Failed to set priority: %v", err)
		}

		// Verifica se o parser de alta prioridade é usado
		redisErr := fmt.Errorf("redis: connection failed")
		ctx := context.Background()
		_, parserName, err := registry.Parse(ctx, redisErr)
		if err != nil {
			t.Errorf("Parsing failed: %v", err)
		}

		if parserName != "redis" {
			t.Errorf("Expected redis parser to be used, got %s", parserName)
		}
	})

	// Testa GetMetrics
	t.Run("GetMetrics", func(t *testing.T) {
		// Faz alguns parsings para gerar métricas
		ctx := context.Background()
		testErrors := []error{
			fmt.Errorf("redis: connection failed"),
			fmt.Errorf("404 Not Found"),
			fmt.Errorf("mongo: duplicate key"),
		}

		for _, err := range testErrors {
			_, _, _ = registry.Parse(ctx, err)
		}

		// Verifica métricas
		metrics, err := registry.GetMetrics("test")
		if err != nil {
			t.Errorf("Expected metrics, got error: %v", err)
		}
		if metrics == nil {
			t.Error("Expected metrics to be populated")
		}
	})

	// Testa RegisterFactory
	t.Run("RegisterFactory", func(t *testing.T) {
		factory := NewCustomParserFactory()
		err := registry.RegisterFactory("custom_factory", factory)
		if err != nil {
			t.Errorf("Failed to register factory: %v", err)
		}
	})

	// Testa RegisterHealthChecker e HealthCheck
	t.Run("HealthCheck", func(t *testing.T) {
		healthChecker := func() error {
			return nil // Healthy
		}

		registry.RegisterHealthChecker("test_checker", healthChecker)

		healthResults := registry.HealthCheck("test")
		if len(healthResults) == 0 {
			t.Error("Expected health check results")
		}
	})
}

// TestDistributedRegistryGlobalFunctions testa as funções globais
func TestDistributedRegistryGlobalFunctions(t *testing.T) {
	t.Run("GlobalParserRegistry", func(t *testing.T) {
		globalRegistry := GetGlobalParserRegistry()
		if globalRegistry == nil {
			t.Error("Global registry should not be nil")
		}

		// Testa parsing com registry global
		err := fmt.Errorf("redis: connection failed")
		ctx := context.Background()
		parsed, parserName, parseErr := ParseWithGlobalRegistry(ctx, err)

		if parseErr != nil {
			t.Errorf("Global parsing failed: %v", parseErr)
		}
		if parsed == nil {
			t.Error("Parsed result should not be nil")
		}
		if parserName == "" {
			t.Error("Parser name should not be empty")
		}
	})
}

// TestGenericDatabasePluginAdvanced testa funcionalidades avançadas do plugin
func TestGenericDatabasePluginAdvanced(t *testing.T) {
	plugin := NewGenericDatabasePlugin()

	t.Run("PluginMetadata", func(t *testing.T) {
		// Testa Version
		version := plugin.Version()
		if version == "" {
			t.Error("Plugin version should not be empty")
		}

		// Testa Description
		description := plugin.Description()
		if description == "" {
			t.Error("Plugin description should not be empty")
		}
	})

	t.Run("ConfigValidation", func(t *testing.T) {
		// Testa configuração inválida
		invalidConfig := map[string]interface{}{
			"patterns": "invalid_type", // Should be array
		}

		err := plugin.ValidateConfig(invalidConfig)
		if err == nil {
			t.Error("Expected validation error for invalid config")
		}

		// Testa configuração com códigos de erro inválidos
		invalidCodesConfig := map[string]interface{}{
			"patterns":    []interface{}{"test"},
			"error_codes": "invalid_type", // Should be map
		}

		err = plugin.ValidateConfig(invalidCodesConfig)
		if err == nil {
			t.Error("Expected validation error for invalid error_codes")
		}
	})

	t.Run("ParserCreationWithCustomConfig", func(t *testing.T) {
		customConfig := map[string]interface{}{
			"patterns": []interface{}{"custom_error_pattern"},
			"error_codes": map[string]interface{}{
				"custom": "CUSTOM_DB_ERROR",
			},
		}

		parser, err := plugin.CreateParser(customConfig)
		if err != nil {
			t.Errorf("Failed to create parser with custom config: %v", err)
		}

		// Testa parsing com configuração customizada
		testErr := fmt.Errorf("custom_error_pattern occurred")
		if !parser.CanParse(testErr) {
			t.Error("Parser should be able to parse custom error")
		}

		parsed := parser.Parse(testErr)
		if parsed.Code != "CUSTOM_DB_ERROR" {
			t.Errorf("Expected CUSTOM_DB_ERROR, got %s", parsed.Code)
		}
	})
}

// TestCustomParserFactoryAdvanced testa funcionalidades avançadas da factory customizada
func TestCustomParserFactoryAdvanced(t *testing.T) {
	factory := NewCustomParserFactory()

	t.Run("SupportedTypes", func(t *testing.T) {
		types := factory.SupportedTypes()
		expectedTypes := []string{"regex_matcher", "keyword_matcher", "json_error_parser"}

		for _, expectedType := range expectedTypes {
			found := false
			for _, supportedType := range types {
				if supportedType == expectedType {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("Expected supported type %s not found", expectedType)
			}
		}
	})

	t.Run("RegisterCustomType", func(t *testing.T) {
		customCreator := func(config map[string]interface{}) (interfaces.ErrorParser, error) {
			return &KeywordMatcherParser{
				keywords:  []string{"custom"},
				errorCode: "CUSTOM_TYPE_ERROR",
			}, nil
		}

		err := factory.RegisterCustomType("custom_type", customCreator)
		if err != nil {
			t.Errorf("Failed to register custom type: %v", err)
		}

		// Testa criação com tipo customizado
		parser, err := factory.CreateParser("custom_type", map[string]interface{}{})
		if err != nil {
			t.Errorf("Failed to create custom parser: %v", err)
		}

		testErr := fmt.Errorf("custom error occurred")
		if !parser.CanParse(testErr) {
			t.Error("Custom parser should be able to parse error")
		}
	})

	t.Run("JSONErrorParser", func(t *testing.T) {
		jsonConfig := map[string]interface{}{
			"error_field": "error",
			"code_field":  "code",
		}

		parser, err := factory.CreateParser("json_error_parser", jsonConfig)
		if err != nil {
			t.Errorf("Failed to create JSON parser: %v", err)
		}

		// Testa parsing de erro JSON
		jsonErr := fmt.Errorf(`{"error": "validation failed", "code": "VALIDATION_ERROR"}`)
		if !parser.CanParse(jsonErr) {
			t.Error("JSON parser should be able to parse JSON error")
		}

		parsed := parser.Parse(jsonErr)
		if parsed.Code != "VALIDATION_ERROR" {
			t.Errorf("Expected VALIDATION_ERROR, got %s", parsed.Code)
		}
	})

	t.Run("InvalidParserType", func(t *testing.T) {
		_, err := factory.CreateParser("invalid_type", map[string]interface{}{})
		if err == nil {
			t.Error("Expected error for invalid parser type")
		}
	})
}

// TestEnhancedPostgreSQLErrorParser testa o parser PostgreSQL aprimorado
func TestEnhancedPostgreSQLErrorParser(t *testing.T) {
	parser := NewEnhancedPostgreSQLErrorParser() // sem argumentos

	tests := []struct {
		name         string
		err          error
		expectedCode string
		canParse     bool
	}{
		{
			name:         "Enhanced PostgreSQL error",
			err:          fmt.Errorf("pq: relation \"users\" does not exist (SQLSTATE 42P01)"),
			expectedCode: "DB_42P01_ENHANCED",
			canParse:     true,
		},
		{
			name:         "Regular PostgreSQL error",
			err:          fmt.Errorf("postgres: connection failed"),
			expectedCode: "DB_UNKNOWN_ENHANCED",
			canParse:     true,
		},
		{
			name:     "Non-PostgreSQL error",
			err:      fmt.Errorf("redis: connection failed"),
			canParse: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			canParse := parser.CanParse(tt.err)
			if canParse != tt.canParse {
				t.Errorf("CanParse() = %v, want %v", canParse, tt.canParse)
			}

			if tt.canParse {
				parsed := parser.Parse(tt.err)
				if parsed.Code != tt.expectedCode {
					t.Errorf("Parse().Code = %v, want %v", parsed.Code, tt.expectedCode)
				}
			}
		})
	}
}

// TestParserErrorHandling testa tratamento de erros dos parsers
func TestParserErrorHandling(t *testing.T) {
	t.Run("ParseWithNilError", func(t *testing.T) {
		parser := NewPostgreSQLErrorParser()

		// Testa CanParse com nil
		if parser.CanParse(nil) {
			t.Error("Parser should not be able to parse nil error")
		}
	})

	t.Run("DistributedRegistryParseWithNilError", func(t *testing.T) {
		registry := NewDistributedParserRegistry()
		ctx := context.Background()

		_, _, err := registry.Parse(ctx, nil)
		if err == nil {
			t.Error("Expected error when parsing nil")
		}
	})

	t.Run("CompositeParserWithNoParsers", func(t *testing.T) {
		composite := NewCompositeErrorParser()

		testErr := fmt.Errorf("some error")
		if composite.CanParse(testErr) {
			t.Error("Composite parser with no parsers should not parse anything")
		}
	})
}
