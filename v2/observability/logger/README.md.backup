# Logger v2 üöÄ

[![Go Version](https://img.shields.io/badgo test github.com/fsvxavier/nexs-lib/v2/observability/logger
```

## üöÄ Quick Start

### Uso B√°sico1.23.3+-blue.svg)](https://golang.org/dl/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Test Coverage](https://img.shields.io/badge/coverage-89.4%25-brightgreen.svg)](https://github.com/fsvxavier/nexs-lib)
[![Performance](https://img.shields.io/badge/benchmark-22,684ns/op-yellow.svg)](./benchmark_test.go)
[![Go Report Card](https://goreportcard.com/badge/github.com/fsvxavier/nexs-lib)](https://goreportcard.com/report/github.com/fsvxavier/nexs-lib)

Sistema de logging estruturado de alta performance para aplica√ß√µes Go modernas. Implementa **Arquitetura Hexagonal**, **princ√≠pios SOLID** e otimiza√ß√µes avan√ßadas de performance com suporte a m√∫ltiplos providers.

## ‚ú® Caracter√≠sticas

### üèóÔ∏è Arquitetura
- **Hexagonal Architecture** - Separa√ß√£o clara entre portas e adaptadores
- **SOLID Principles** - Dependency injection, single responsibility, interface segregation
- **Factory Pattern** - Cria√ß√£o e gerenciamento centralizado de loggers
- **Thread-Safe** - Concorr√™ncia segura com prote√ß√£o de dados

### ‚ö° Performance
- **Async Processing** - Pool de workers configur√°veis (22,684 ns/op)
- **Smart Sampling** - Controle inteligente de volume de logs
- **Object Pooling** - Reutiliza√ß√£o de objetos para reduzir GC pressure
- **Zero Allocation** - Otimizado para minimal memory footprint

### üîå Providers Suportados
- **[Zap](https://github.com/uber-go/zap)** - Ultra-high performance structured logging
- **[Slog](https://pkg.go.dev/log/slog)** - Go stdlib structured logging (1.21+)
- **[Zerolog](https://github.com/rs/zerolog)** - Zero allocation JSON logger

### üéØ Funcionalidades Avan√ßadas
- **Structured Logging** - Campos tipados com valida√ß√£o completa
- **Context Awareness** - Extra√ß√£o autom√°tica de trace/span/user IDs
- **Hooks & Middleware** - Sistema extens√≠vel de intercepta√ß√£o
- **Metrics Collection** - Coleta autom√°tica de m√©tricas de observabilidade
- **Multiple Formats** - JSON, Console, Text com configura√ß√£o flex√≠vel

## üì¶ Instala√ß√£o

### Instala√ß√£o B√°sica
```bash
go get github.com/fsvxavier/nexs-lib/v2/observability/logger
```

### Depend√™ncias Opcionais
```bash
# Para usar provider Zap
go get go.uber.org/zap

# Para usar provider Zerolog  
go get github.com/rs/zerolog

# Slog j√° est√° inclu√≠do no Go 1.21+
```

### Verifica√ß√£o da Instala√ß√£o
```bash
go mod tidy
go test github.com/fsvxavier/nexs-lib/v2/observability/logger
```

## ÔøΩ Quick Start

### Uso B√°sico
```go
package main

import (
    "context"
    "github.com/fsvxavier/nexs-lib/v2/observability/logger"
    "github.com/fsvxavier/nexs-lib/v2/observability/logger/interfaces"
)

func main() {
    // 1. Configura√ß√£o simples
    config := interfaces.Config{
        Level:          interfaces.InfoLevel,
        Format:         interfaces.JSONFormat,
        ServiceName:    "my-service",
        ServiceVersion: "v1.0.0",
        Environment:    "production",
        AddCaller:      true,
    }

    // 2. Define o provider
    err := logger.SetProvider("zap", config)
    if err != nil {
        panic(err)
    }

    // 3. Usa o logger
    log := logger.GetCurrentLogger()
    ctx := context.Background()

    log.Info(ctx, "Aplica√ß√£o iniciada",
        interfaces.String("version", "1.0.0"),
        interfaces.Int("port", 8080),
    )
}
```

### Configura√ß√£o de Produ√ß√£o
```go
config := interfaces.Config{
    Level:          interfaces.InfoLevel,
    Format:         interfaces.JSONFormat,
    ServiceName:    "production-service",
    ServiceVersion: "v2.1.0",
    Environment:    "production",
    AddCaller:      true,
    AddStacktrace:  true,
    TimeFormat:     time.RFC3339Nano,
    
    // Otimiza√ß√µes de performance
    AsyncProcessing: true,
    BufferSize:     1000,
    Workers:        4,
    
    // Sampling para controle de volume
    SamplingConfig: &interfaces.SamplingConfig{
        Initial:    100,  // Primeiros 100 logs/sec
        Thereafter: 100,  // Depois, 1 a cada 100
    },
    
    // Campos globais
    GlobalFields: map[string]interface{}{
        "service_id": "srv-prod-001",
        "region":     "us-east-1",
        "zone":       "prod",
    },
}

logger.SetProvider("zap", config)
```

## üìù Exemplos de Uso

### Logging Estruturado
```go
log := logger.GetCurrentLogger()
ctx := context.Background()

// Campos tipados com valida√ß√£o
log.Info(ctx, "Opera√ß√£o realizada com sucesso",
    interfaces.String("operation", "create_user"),
    interfaces.Int64("user_id", 12345),
    interfaces.Float64("duration_ms", 245.7),
    interfaces.Bool("success", true),
    interfaces.Time("timestamp", time.Now()),
    interfaces.Duration("elapsed", time.Millisecond*245),
)

// Logging com c√≥digo de opera√ß√£o
log.InfoWithCode(ctx, "USER_CREATED", "Usu√°rio criado",
    interfaces.String("email", "user@example.com"),
    interfaces.String("role", "admin"),
)
```

### Context Awareness Autom√°tico
```go
// Context com trace/span IDs
traceCtx := context.WithValue(ctx, "trace_id", "trace-abc123")
spanCtx := context.WithValue(traceCtx, "span_id", "span-def456")

// Logger extrai automaticamente IDs do context
log.Info(spanCtx, "Request processado")
// Output: {"level":"info","msg":"Request processado","trace_id":"trace-abc123","span_id":"span-def456"}

// Ou definindo explicitamente
log.WithTraceID("trace-123").
    WithSpanID("span-456").
    WithUserID("user-789").
    Info(ctx, "Opera√ß√£o autenticada")
```

### Logger com Campos Persistentes
```go
// Logger espec√≠fico do usu√°rio
userLogger := log.WithFields(
    interfaces.String("user_id", "user-123"),
    interfaces.String("session_id", "sess-456"),
    interfaces.String("tenant", "company-abc"),
)

// Todos os logs incluem esses campos automaticamente
userLogger.Info(ctx, "Login realizado")
userLogger.Debug(ctx, "P√°gina dashboard acessada")
userLogger.Warn(ctx, "Tentativa de acesso negada")
```

### Error Handling Avan√ßado
```go
// Com stack trace autom√°tico
err := performDatabaseOperation()
if err != nil {
    log.WithError(err).Error(ctx, "Falha na opera√ß√£o de banco",
        interfaces.String("operation", "user_query"),
        interfaces.String("table", "users"),
        interfaces.String("query_id", "q-123"),
        interfaces.Duration("timeout", 5*time.Second),
    )
}

// Fatal com graceful shutdown
log.Fatal(ctx, "Falha cr√≠tica no sistema",
    interfaces.String("component", "database"),
    interfaces.String("error", err.Error()),
)
```

### Formata√ß√£o Printf-Style
```go
// Compatibilidade com printf
log.Infof(ctx, "Processados %d registros em %v", count, duration)
log.Errorf(ctx, "Falha ao conectar com %s:%d - %v", host, port, err)
log.Debugf(ctx, "Cache hit ratio: %.2f%%", hitRatio*100)
```

## ‚öôÔ∏è Configura√ß√£o Avan√ßada

### Configura√ß√£o por Ambiente
```go
// Development
devConfig := interfaces.Config{
    Level:     interfaces.DebugLevel,
    Format:    interfaces.ConsoleFormat,
    AddCaller: true,
    Development: true,
}

// Testing
testConfig := interfaces.Config{
    Level:  interfaces.WarnLevel,
    Format: interfaces.JSONFormat,
    Output: testBuffer, // Buffer para testes
}

// Production
prodConfig := interfaces.Config{
    Level:          interfaces.InfoLevel,
    Format:         interfaces.JSONFormat,
    AsyncProcessing: true,
    BufferSize:     10000,
    Workers:        8,
    SamplingConfig: &interfaces.SamplingConfig{
        Initial:    100,
        Thereafter: 1000,
    },
}
```

### Workers e Buffer Sizing
```go
config := interfaces.Config{
    AsyncProcessing: true,
    BufferSize:     1000,   // Tamanho do buffer interno
    Workers:        4,      // N√∫mero de workers ass√≠ncronos
    FlushTimeout:   5 * time.Second, // Timeout para flush
}

// Auto-tuning baseado em CPU cores
config.Workers = runtime.NumCPU()
config.BufferSize = config.Workers * 250
```

## ÔøΩ Compara√ß√£o de Providers

### Performance Benchmarks
| Provider | Throughput (ops/sec) | Latency (ns/op) | Memory (B/op) | Allocs/op | Recomendado Para |
|----------|---------------------|-----------------|---------------|-----------|------------------|
| **Zap** | 1,000,000 | 1,200 | 240 | 3 | üèÜ Produ√ß√£o de alta performance |
| **Zerolog** | 1,200,000 | 800 | 180 | 2 | ü•á M√°xima performance, zero-allocation |
| **Slog** | 800,000 | 1,500 | 320 | 5 | üìö Desenvolvimento, stdlib |

### Caracter√≠sticas por Provider

#### üöÄ Zap (Recomendado para Produ√ß√£o)
```go
// Configura√ß√£o otimizada
config := interfaces.Config{
    Level:          interfaces.InfoLevel,
    Format:         interfaces.JSONFormat,
    AddCaller:      true,
    AddStacktrace:  true,
    AsyncProcessing: true,  // Excelente performance ass√≠ncrona
}
logger.SetProvider("zap", config)
```

**‚úÖ Vantagens:**
- Ultra-high performance em produ√ß√£o
- Excelente suporte a structured logging
- Otimiza√ß√µes avan√ßadas de memory allocation
- Sampling inteligente built-in
- Stack traces detalhados

**‚ö†Ô∏è Considera√ß√µes:**
- Depend√™ncia externa (go.uber.org/zap)
- Curva de aprendizado para configura√ß√µes avan√ßadas

---

#### ‚ö° Zerolog (M√°xima Performance)
```go
// Configura√ß√£o zero-allocation
config := interfaces.Config{
    Level:     interfaces.InfoLevel,
    Format:    interfaces.JSONFormat,  // Formato nativo
    AddCaller: false,  // Evita overhead desnecess√°rio
}
logger.SetProvider("zerolog", config)
```

**‚úÖ Vantagens:**
- Zero allocation logging
- Menor lat√™ncia entre todos os providers
- JSON nativo, extremamente eficiente
- Ideal para microservices

**‚ö†Ô∏è Considera√ß√µes:**
- Funcionalidades limitadas vs Zap
- Depend√™ncia externa (github.com/rs/zerolog)
- Menos flexibilidade de formata√ß√£o

---

#### üìö Slog (Stdlib, Desenvolvimento)
```go
// Configura√ß√£o para desenvolvimento
config := interfaces.Config{
    Level:       interfaces.DebugLevel,
    Format:      interfaces.ConsoleFormat,  // Melhor legibilidade
    AddCaller:   true,
    Development: true,
}
logger.SetProvider("slog", config)
```

**‚úÖ Vantagens:**
- Parte do Go stdlib (sem depend√™ncias)
- API familiar e consistente
- Ideal para desenvolvimento e testes
- Boa integra√ß√£o com ferramentas padr√£o

**‚ö†Ô∏è Considera√ß√µes:**
- Performance inferior vs bibliotecas especializadas
- Funcionalidades limitadas para produ√ß√£o
- Dispon√≠vel apenas Go 1.21+

### Guia de Escolha

```go
// üè≠ PRODU√á√ÉO - Alta performance, muitos logs
logger.SetProvider("zap", prodConfig)

// ‚ö° MICROSERVICES - M√°xima efici√™ncia, baixa lat√™ncia  
logger.SetProvider("zerolog", microConfig)

// üß™ DESENVOLVIMENTO - Simplicidade, sem depend√™ncias
logger.SetProvider("slog", devConfig)
```

### Migra√ß√£o Entre Providers
```go
// Troca din√¢mica de provider (sem restart)
currentProvider := logger.GetCurrentProvider()
fmt.Printf("Provider atual: %s\n", currentProvider)

// Muda para outro provider mantendo configura√ß√£o
newConfig := config
newConfig.Format = interfaces.ConsoleFormat
logger.SetProvider("slog", newConfig)

// Valida se mudan√ßa foi bem-sucedida
if logger.GetCurrentProvider() == "slog" {
    log.Info(ctx, "Provider alterado com sucesso")
}
```

## üéØ Casos de Uso Avan√ßados

### Middleware de HTTP Request
```go
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        requestID := generateRequestID()
        
        // Context com request metadata
        ctx := context.WithValue(r.Context(), "request_id", requestID)
        ctx = context.WithValue(ctx, "user_agent", r.UserAgent())
        
        // Logger especializado para request
        reqLogger := logger.GetCurrentLogger().WithFields(
            interfaces.String("method", r.Method),
            interfaces.String("path", r.URL.Path),
            interfaces.String("request_id", requestID),
            interfaces.String("remote_addr", r.RemoteAddr),
        )
        
        reqLogger.Info(ctx, "Request iniciado")
        
        // Wrapper para capturar status code
        wrapped := &responseWriter{ResponseWriter: w, statusCode: 200}
        
        // Processa request
        next.ServeHTTP(wrapped, r.WithContext(ctx))
        
        // Log de conclus√£o com m√©tricas
        duration := time.Since(start)
        reqLogger.Info(ctx, "Request conclu√≠do",
            interfaces.Int("status_code", wrapped.statusCode),
            interfaces.Duration("duration", duration),
            interfaces.Int64("response_size", wrapped.written),
        )
        
        // Log de warning para requests lentos
        if duration > 1*time.Second {
            reqLogger.Warn(ctx, "Request lento detectado",
                interfaces.Duration("threshold", 1*time.Second),
            )
        }
    })
}

type responseWriter struct {
    http.ResponseWriter
    statusCode int
    written    int64
}

func (w *responseWriter) WriteHeader(code int) {
    w.statusCode = code
    w.ResponseWriter.WriteHeader(code)
}

func (w *responseWriter) Write(data []byte) (int, error) {
    n, err := w.ResponseWriter.Write(data)
    w.written += int64(n)
    return n, err
}
```

### Factory Pattern Customizada
```go
// Factory espec√≠fica para microservice
type ServiceLoggerFactory struct {
    serviceName    string
    serviceVersion string
    defaultConfig  interfaces.Config
}

func NewServiceLoggerFactory(name, version string) *ServiceLoggerFactory {
    return &ServiceLoggerFactory{
        serviceName:    name,
        serviceVersion: version,
        defaultConfig: interfaces.Config{
            Level:          interfaces.InfoLevel,
            Format:         interfaces.JSONFormat,
            ServiceName:    name,
            ServiceVersion: version,
            AddCaller:      true,
            AsyncProcessing: true,
            GlobalFields: map[string]interface{}{
                "service": name,
                "version": version,
            },
        },
    }
}

func (f *ServiceLoggerFactory) CreateDomainLogger(domain string) interfaces.Logger {
    config := f.defaultConfig
    config.GlobalFields["domain"] = domain
    
    factory := logger.NewFactory()
    domainLogger, _ := factory.CreateLogger(domain, config)
    return domainLogger
}

// Uso
factory := NewServiceLoggerFactory("user-service", "v2.1.0")
userLogger := factory.CreateDomainLogger("user-management")
authLogger := factory.CreateDomainLogger("authentication")
```

### Sistema de Hooks Avan√ßado
```go
// Hook para alertas cr√≠ticos
type AlertHook struct {
    alertManager AlertManager
    levels      []interfaces.Level
}

func NewAlertHook(am AlertManager) *AlertHook {
    return &AlertHook{
        alertManager: am,
        levels:      []interfaces.Level{interfaces.ErrorLevel, interfaces.FatalLevel},
    }
}

func (h *AlertHook) Fire(entry interfaces.LogEntry) error {
    // Envia alerta apenas para erros cr√≠ticos
    if entry.Level >= interfaces.ErrorLevel {
        alert := Alert{
            Level:     entry.Level.String(),
            Message:   entry.Message,
            Service:   entry.ServiceName,
            Timestamp: entry.Time,
            Fields:    entry.Fields,
        }
        
        // Envia de forma ass√≠ncrona para n√£o bloquear logging
        go func() {
            if err := h.alertManager.Send(alert); err != nil {
                // Log interno do erro de alerta (evita recurs√£o)
                fmt.Printf("Falha ao enviar alerta: %v\n", err)
            }
        }()
    }
    return nil
}

func (h *AlertHook) Levels() []interfaces.Level {
    return h.levels
}

// Hook para m√©tricas personalizadas
type MetricsHook struct {
    collector MetricsCollector
}

func (h *MetricsHook) Fire(entry interfaces.LogEntry) error {
    h.collector.IncrementLogsTotal(entry.Level.String(), entry.ServiceName)
    
    if entry.Level >= interfaces.ErrorLevel {
        h.collector.IncrementErrorsTotal(entry.ServiceName)
    }
    
    return nil
}

// Registro de hooks
config.Hooks = []interfaces.Hook{
    NewAlertHook(alertManager),
    &MetricsHook{collector: prometheusCollector},
}
```

### Configura√ß√£o por Environment Variables
```go
func LoadConfigFromEnv() interfaces.Config {
    config := interfaces.Config{
        Level:          parseLevel(getEnv("LOG_LEVEL", "info")),
        Format:         parseFormat(getEnv("LOG_FORMAT", "json")),
        ServiceName:    getEnv("SERVICE_NAME", "unknown"),
        ServiceVersion: getEnv("SERVICE_VERSION", "v0.0.0"),
        Environment:    getEnv("ENVIRONMENT", "development"),
        AddCaller:      parseBool(getEnv("LOG_ADD_CALLER", "true")),
        AddStacktrace:  parseBool(getEnv("LOG_ADD_STACKTRACE", "false")),
        AsyncProcessing: parseBool(getEnv("LOG_ASYNC", "true")),
        BufferSize:     parseInt(getEnv("LOG_BUFFER_SIZE", "1000")),
        Workers:        parseInt(getEnv("LOG_WORKERS", "4")),
    }
    
    // Sampling configuration
    if getEnv("LOG_SAMPLING_ENABLED", "true") == "true" {
        config.SamplingConfig = &interfaces.SamplingConfig{
            Initial:    parseInt(getEnv("LOG_SAMPLING_INITIAL", "100")),
            Thereafter: parseInt(getEnv("LOG_SAMPLING_THEREAFTER", "100")),
        }
    }
    
    return config
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}
```

## üîç Observabilidade e M√©tricas

### M√©tricas Autom√°ticas
O logger coleta automaticamente m√©tricas de observabilidade:

```go
// M√©tricas coletadas automaticamente
- logger_messages_total{level="info",provider="zap",service="my-service"}
- logger_errors_total{provider="zap",service="my-service"}  
- logger_async_queue_size{provider="zap"}
- logger_processing_duration_seconds{provider="zap",level="info"}
- logger_sampling_rate{provider="zap"}
```

### Health Check do Sistema
```go
// Verifica√ß√£o de sa√∫de dos providers
healthStatus := logger.HealthCheck()
if !healthStatus.Healthy {
    log.Error(ctx, "Logger com problemas",
        interfaces.String("provider", healthStatus.Provider),
        interfaces.String("error", healthStatus.Error),
        interfaces.Duration("uptime", healthStatus.Uptime),
    )
}

// Lista providers dispon√≠veis
providers := logger.ListProviders()
log.Info(ctx, "Providers dispon√≠veis", 
    interfaces.Strings("providers", providers))
```

### Monitoring Dashboard
```go
// Endpoint para m√©tricas (Prometheus format)
func metricsHandler(w http.ResponseWriter, r *http.Request) {
    metrics := logger.GetMetrics()
    
    // Formato Prometheus
    fmt.Fprintf(w, "# HELP logger_messages_total Total log messages\n")
    fmt.Fprintf(w, "# TYPE logger_messages_total counter\n")
    
    for level, count := range metrics.MessagesByLevel {
        fmt.Fprintf(w, `logger_messages_total{level="%s"} %d`+"\n", level, count)
    }
}
```

## üß™ Testing

### Configura√ß√£o para Testes
```go
func setupTestLogger(t *testing.T) interfaces.Logger {
    // Buffer para capturar logs em testes
    var buf bytes.Buffer
    
    config := interfaces.Config{
        Level:     interfaces.DebugLevel,
        Format:    interfaces.JSONFormat,
        Output:    &buf,  // Redireciona para buffer
        AddCaller: false, // N√£o necess√°rio em testes
    }
    
    logger.SetProvider("slog", config)
    return logger.GetCurrentLogger()
}

func TestMyFunction(t *testing.T) {
    log := setupTestLogger(t)
    
    // Sua fun√ß√£o que usa logging
    myFunction(log)
    
    // Verifica se logs foram gerados corretamente
    // (implementa√ß√£o espec√≠fica baseada no buffer)
}
```

### Mocks para Testing
```go
// Mock logger para testes unit√°rios
type MockLogger struct {
    LoggedMessages []LogEntry
}

func (m *MockLogger) Info(ctx context.Context, msg string, fields ...interfaces.Field) {
    m.LoggedMessages = append(m.LoggedMessages, LogEntry{
        Level:   "info",
        Message: msg,
        Fields:  fields,
        Context: ctx,
    })
}

// Uso nos testes
func TestBusinessLogic(t *testing.T) {
    mockLogger := &MockLogger{}
    
    // Injeta mock
    service := NewService(mockLogger)
    service.ProcessUser("user-123")
    
    // Verifica logs gerados
    assert.Len(t, mockLogger.LoggedMessages, 2)
    assert.Equal(t, "User processed", mockLogger.LoggedMessages[0].Message)
}
```

## üìä Performance Tuning

### Otimiza√ß√µes de Performance
```go
// Para alta throughput (>10k msgs/sec)
highThroughputConfig := interfaces.Config{
    AsyncProcessing: true,
    BufferSize:     10000,
    Workers:        runtime.NumCPU() * 2,
    SamplingConfig: &interfaces.SamplingConfig{
        Initial:    1000,
        Thereafter: 1000,
    },
}

// Para baixa lat√™ncia (<1ms p99)
lowLatencyConfig := interfaces.Config{
    AsyncProcessing: false,  // Sync para menor lat√™ncia
    AddCaller:      false,   // Remove overhead
    AddStacktrace:  false,   // Remove overhead
    Format:         interfaces.JSONFormat,
}

// Para desenvolvimento (debugging)
debugConfig := interfaces.Config{
    Level:         interfaces.DebugLevel,
    Format:        interfaces.ConsoleFormat,
    AddCaller:     true,
    AddStacktrace: true,
    Development:   true,
}
```

### Level Checking Otimizado
```go
// ‚ùå Evite: sempre calcula campo caro
log.Debug(ctx, "Debug info", expensiveFieldCalculation())

// ‚úÖ Recomendado: verifica level primeiro
if log.IsLevelEnabled(interfaces.DebugLevel) {
    log.Debug(ctx, "Debug info", expensiveFieldCalculation())
}

// ‚úÖ Melhor ainda: lazy evaluation
log.Debug(ctx, "Debug info", interfaces.Lazy(func() interfaces.Field {
    return expensiveFieldCalculation()
}))
```

### Memory Pool Tuning
```go
// Configura√ß√£o de memory pools
config.PoolConfig = &interfaces.PoolConfig{
    EntryPoolSize:  1000,  // Pool de entries
    BufferPoolSize: 500,   // Pool de buffers
    FieldPoolSize:  2000,  // Pool de fields
    MaxPoolSize:    10000, // Tamanho m√°ximo dos pools
}
```

## üöÄ Deployment

### Docker Configuration
```dockerfile
# Dockerfile
FROM golang:1.23-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -ldflags="-w -s" -o app ./cmd/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/app .

# Environment variables para logging
ENV LOG_LEVEL=info
ENV LOG_FORMAT=json
ENV LOG_ASYNC=true
ENV LOG_BUFFER_SIZE=1000

CMD ["./app"]
```

### Kubernetes ConfigMap
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: logger-config
data:
  LOG_LEVEL: "info"
  LOG_FORMAT: "json"
  LOG_ADD_CALLER: "true"
  LOG_ASYNC: "true"
  LOG_BUFFER_SIZE: "5000"
  LOG_WORKERS: "4"
  LOG_SAMPLING_ENABLED: "true"
  LOG_SAMPLING_INITIAL: "100"
  LOG_SAMPLING_THEREAFTER: "1000"
```

### Production Checklist
```bash
# ‚úÖ Checklist de produ√ß√£o
- [ ] Provider configurado (zap recomendado)
- [ ] Async processing habilitado
- [ ] Sampling configurado para alta carga
- [ ] M√©tricas de observabilidade ativas
- [ ] Health checks implementados
- [ ] Log rotation configurado (external)
- [ ] Alertas para erros cr√≠ticos
- [ ] Buffer size otimizado para carga esperada
- [ ] Workers configurados baseado em CPU cores
```

## üîÑ Migra√ß√£o e Compatibilidade

### Migra√ß√£o da v1 para v2
```go
// ‚ùå v1 (deprecated)
import "github.com/fsvxavier/nexs-lib/observability/logger"

zapLogger := logger.NewZapLogger(zapConfig)
zapLogger.Info("message", zap.String("key", "value"))

// ‚úÖ v2 (recomendado)
import "github.com/fsvxavier/nexs-lib/v2/observability/logger"
import "github.com/fsvxavier/nexs-lib/v2/observability/logger/interfaces"

config := interfaces.Config{
    Level:  interfaces.InfoLevel,
    Format: interfaces.JSONFormat,
}
logger.SetProvider("zap", config)
log := logger.GetCurrentLogger()
log.Info(ctx, "message", interfaces.String("key", "value"))
```

### Compatibilidade com Outras Bibliotecas
```go
// Wrapper para compatibilidade com logrus
type LogrusAdapter struct {
    logger interfaces.Logger
}

func (l *LogrusAdapter) WithFields(fields logrus.Fields) *logrus.Entry {
    var loggerFields []interfaces.Field
    for k, v := range fields {
        loggerFields = append(loggerFields, interfaces.Any(k, v))
    }
    
    contextLogger := l.logger.WithFields(loggerFields...)
    return &logrus.Entry{Logger: &LogrusCompatLogger{contextLogger}}
}

// Uso
adapter := &LogrusAdapter{logger: logger.GetCurrentLogger()}
entry := adapter.WithFields(logrus.Fields{"user_id": "123"})
entry.Info("User logged in")
```

## üìö Recursos Adicionais

### Exemplos Completos
- **[Basic Usage](./examples/basic/)** - Configura√ß√£o b√°sica e uso simples
- **[Advanced Features](./examples/advanced/)** - Recursos avan√ßados e otimiza√ß√µes
- **[HTTP Middleware](./examples/middleware/)** - Integra√ß√£o com servidores HTTP
- **[Microservices](./examples/microservices/)** - Padr√µes para microservices
- **[Performance](./examples/performance/)** - Otimiza√ß√µes e benchmarks
- **[Testing](./examples/testing/)** - Estrat√©gias de teste
- **[Production](./examples/production/)** - Configura√ß√µes de produ√ß√£o
- **[Monitoring](./examples/monitoring/)** - Observabilidade e m√©tricas

### Links √öteis
- üìñ **[Documenta√ß√£o API](https://pkg.go.dev/github.com/fsvxavier/nexs-lib/v2/observability/logger)**
- üöÄ **[Benchmarks Detalhados](./benchmark_test.go)**
- üß™ **[Suite de Testes](./integration_test.go)**
- üìä **[Relat√≥rio de Cobertura](./coverage.html)**
- üéØ **[Roadmap](./next_steps.md)**

## ü§ù Contribuindo

### Setup do Ambiente
```bash
# Clone o reposit√≥rio
git clone https://github.com/fsvxavier/nexs-lib.git
cd nexs-lib/v2/observability/logger

# Instale depend√™ncias
go mod tidy

# Execute testes
go test -v ./...

# Verifique cobertura
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

# Execute linting
golangci-lint run
```

### Processo de Contribui√ß√£o
1. üç¥ Fork o projeto
2. üåø Crie uma feature branch (`git checkout -b feature/amazing-feature`)
3. ‚úÖ Implemente com cobertura ‚â•98%
4. üìù Commit suas mudan√ßas (`git commit -m 'Add amazing feature'`)
5. üì§ Push para a branch (`git push origin feature/amazing-feature`)
6. üîÑ Abra um Pull Request

### Padr√µes de C√≥digo
- **Cobertura m√≠nima**: 98%
- **Naming convention**: `*_test.go` para unit tests
- **Benchmarks**: Incluir para features de performance
- **Documentation**: Documentar todas as APIs p√∫blicas
- **Examples**: Incluir exemplos pr√°ticos

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a [Licen√ßa MIT](../../../LICENSE). Veja o arquivo LICENSE para detalhes.

## üìû Suporte

- üêõ **Issues**: [GitHub Issues](https://github.com/fsvxavier/nexs-lib/issues)
- üí¨ **Discuss√µes**: [GitHub Discussions](https://github.com/fsvxavier/nexs-lib/discussions)
- üìß **Email**: Abra uma issue para contato direto

---

<div align="center">

**Logger v2** - Logging de alta performance para aplica√ß√µes Go modernas üöÄ

[![Made with ‚ù§Ô∏è by fsvxavier](https://img.shields.io/badge/Made%20with%20‚ù§Ô∏è%20by-fsvxavier-red.svg)](https://github.com/fsvxavier)

</div>
