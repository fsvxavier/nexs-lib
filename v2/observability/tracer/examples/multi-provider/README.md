# Multi-Provider Example

This example demonstrates how to use multiple observability providers simultaneously, sending traces to Datadog, New Relic, and Prometheus all at once from a single application.

## Overview

The multi-provider approach allows you to:
- **Reduce Vendor Lock-in**: Send data to multiple providers for redundancy
- **Compare Providers**: Evaluate different tools with the same data
- **Migration Strategy**: Gradually migrate from one provider to another
- **Different Use Cases**: Use each provider for their strengths (Datadog for APM, Prometheus for alerting, etc.)

## Prerequisites

1. **Go 1.21+**: Required for running the example
2. **Datadog Agent** (Optional): For Datadog APM traces
3. **New Relic License Key** (Optional): For New Relic APM traces
4. **Prometheus Server** (Optional): For scraping metrics

## Setup

### 1. Configure Providers

#### Datadog (Optional)
```bash
# Start Datadog Agent
docker run -d --name datadog-agent \
    -e DD_API_KEY=your_datadog_api_key \
    -e DD_APM_ENABLED=true \
    -p 8126:8126 \
    datadog/agent:latest
```

#### New Relic (Optional)
Replace the license key in `main.go`:
```go
licenseKey := "your-40-character-new-relic-license-key"
```

#### Prometheus (Always Available)
The example includes built-in Prometheus metrics that work without external setup.

### 2. Run the Example

```bash
cd examples/multi-provider
go run main.go
```

You'll see output indicating which providers were successfully initialized:
```
✅ Datadog provider initialized
⚠️  New Relic provider skipped (check license key)
✅ Prometheus provider initialized
Starting multi-provider instrumented server on :8080...
```

## Testing the Service

### Basic Request
```bash
curl http://localhost:8080/
```
Sends traces to all configured providers with basic HTTP metrics.

### Complex Business Transaction
```bash
# Without authentication (demonstrates error tracking)
curl http://localhost:8080/api/orders

# With authentication (demonstrates successful transaction)
curl "http://localhost:8080/api/orders?auth=true"
```

### Health Monitoring
```bash
curl http://localhost:8080/api/health
```
Shows comprehensive health check tracing across all providers.

### Prometheus Metrics
```bash
curl http://localhost:8080/metrics
```
View raw Prometheus metrics generated by the service.

## What You'll See

### In Datadog (if configured)
- **Service**: `multi-provider-example`
- **Traces**: HTTP requests with full span hierarchy
- **Custom Attributes**: 
  - `datadog.service`: Web frontend classification
  - `datadog.resource`: Resource-based grouping
  - `datadog.analytics`: Analytics flag for insights

### In New Relic (if configured)
- **Application**: `multi-provider-example`
- **Transactions**: Business transaction tracking
- **Custom Attributes**:
  - `newrelic.transaction.type`: Transaction classification
  - `newrelic.custom_attribute`: High-value transaction flagging
  - Business metrics for revenue tracking

### In Prometheus (always available)
- **Metrics Namespace**: `multiapp_api_*`
- **Request Metrics**: Duration histograms, request counts
- **Business Metrics**: Health status, order values
- **Custom Labels**: Provider identification, component tracking

## Provider-Specific Benefits

### Datadog Strengths
- **APM Excellence**: Best-in-class application performance monitoring
- **Service Maps**: Automatic service dependency discovery
- **Real User Monitoring**: Frontend performance correlation
- **Log Correlation**: Automatic trace-log correlation

Usage in example:
```go
span.SetAttribute("datadog.service", "web-frontend")
span.SetAttribute("datadog.resource", "GET /api/orders")
span.SetAttribute("datadog.analytics", true)
```

### New Relic Strengths
- **Business Intelligence**: Revenue and conversion tracking
- **Custom Insights**: Business-specific dashboards
- **Alert Intelligence**: ML-powered alerting
- **Deployment Tracking**: Release impact analysis

Usage in example:
```go
span.SetAttribute("newrelic.transaction.type", "business")
span.SetAttribute("newrelic.custom_attribute", "high_value_transaction")
span.SetAttribute("business.revenue_impact", totalValue)
```

### Prometheus Strengths
- **Metrics Excellence**: Best metrics collection and storage
- **Alerting**: Powerful alerting with AlertManager
- **Cost Effective**: Open source, self-hosted
- **Ecosystem**: Rich ecosystem with Grafana, exporters

Usage in example:
```go
span.SetAttribute("prometheus.operation", "orders_list")
span.SetAttribute("prometheus.business_metric", totalValue)
span.SetAttribute("prometheus.health_status", boolToInt(healthy))
```

## Architecture Benefits

### 1. Provider Redundancy
If one provider has issues, others continue collecting data:
```go
// Graceful degradation
if ddTracer, cleanup := setupDatadogTracer(); ddTracer != nil {
    tracers = append(tracers, ddTracer)
} else {
    fmt.Println("⚠️  Datadog provider skipped")
}
```

### 2. Data Consistency
Same trace data sent to all providers ensures consistency:
```go
// Common attributes for all providers
span.SetAttribute("trace_id", generateTraceID())
span.SetAttribute("multi_provider", true)
span.SetAttribute("user.id", userID)
```

### 3. Provider Migration
Easy to migrate between providers by gradually shifting configuration:
```go
// Phase 1: Add new provider alongside existing
// Phase 2: Compare data quality and features
// Phase 3: Remove old provider
```

## Performance Considerations

### Overhead Analysis
```go
// Each span goes to multiple providers
// CPU: 2-3x overhead compared to single provider
// Memory: 1.5-2x overhead for span storage
// Network: N providers × baseline traffic
```

### Optimization Strategies

#### 1. Conditional Provider Setup
```go
func setupOptimizedProviders() []tracer.Tracer {
    var tracers []tracer.Tracer
    
    // High-frequency metrics only to Prometheus
    if needsMetrics() {
        tracers = append(tracers, setupPrometheusTracer())
    }
    
    // Detailed traces only to primary APM
    if needsAPM() {
        tracers = append(tracers, setupDatadogTracer())
    }
    
    return tracers
}
```

#### 2. Sampling Configuration
```go
// Different sampling rates per provider
datadogConfig.SampleRate = 0.1    // 10% for detailed APM
prometheusConfig.SampleRate = 1.0  // 100% for metrics
```

#### 3. Attribute Filtering
```go
// Provider-specific attributes only when needed
if isDatadogEnabled {
    span.SetAttribute("datadog.resource", resource)
}
if isNewRelicEnabled {
    span.SetAttribute("newrelic.transaction", txnType)
}
```

## Advanced Configuration

### Environment-Based Setup
```go
func setupProvidersByEnvironment() []tracer.Tracer {
    env := os.Getenv("ENVIRONMENT")
    
    switch env {
    case "production":
        // Production: Datadog + Prometheus
        return []tracer.Tracer{
            setupDatadogTracer(),
            setupPrometheusTracer(),
        }
    case "staging":
        // Staging: All providers for testing
        return []tracer.Tracer{
            setupDatadogTracer(),
            setupNewRelicTracer(),
            setupPrometheusTracer(),
        }
    default:
        // Development: Prometheus only
        return []tracer.Tracer{
            setupPrometheusTracer(),
        }
    }
}
```

### Feature Flags
```go
type ProviderConfig struct {
    EnableDatadog    bool
    EnableNewRelic   bool
    EnablePrometheus bool
    SamplingRates    map[string]float64
}

func setupProvidersByFlags(config ProviderConfig) []tracer.Tracer {
    var tracers []tracer.Tracer
    
    if config.EnableDatadog {
        tracers = append(tracers, setupDatadogTracer())
    }
    if config.EnableNewRelic {
        tracers = append(tracers, setupNewRelicTracer())
    }
    if config.EnablePrometheus {
        tracers = append(tracers, setupPrometheusTracer())
    }
    
    return tracers
}
```

## Monitoring Multi-Provider Setup

### Health Checks
```go
func checkProviderHealth() map[string]bool {
    return map[string]bool{
        "datadog":    checkDatadogHealth(),
        "newrelic":   checkNewRelicHealth(),
        "prometheus": checkPrometheusHealth(),
    }
}
```

### Performance Metrics
```go
// Track per-provider performance
span.SetAttribute("provider.datadog.latency_ms", ddLatency)
span.SetAttribute("provider.newrelic.latency_ms", nrLatency)
span.SetAttribute("provider.prometheus.latency_ms", promLatency)
```

## Troubleshooting

### Common Issues

#### 1. Provider Initialization Failures
```bash
# Check logs for specific provider errors
⚠️  Datadog provider skipped (check configuration)
❌ New Relic provider failed to initialize
```

#### 2. Performance Degradation
- Monitor CPU and memory usage
- Check network bandwidth to providers
- Consider reducing sampling rates

#### 3. Data Inconsistencies
- Verify trace IDs are consistent across providers
- Check timestamp synchronization
- Validate attribute mapping

### Debugging Tips

#### 1. Enable Debug Logging
```go
config := &datadog.Config{
    Debug: true,  // Enable debug logging
}
```

#### 2. Compare Provider Data
Use consistent trace IDs to correlate data across providers:
```go
traceID := generateTraceID()
span.SetAttribute("trace_id", traceID)
```

#### 3. Monitor Provider Health
```bash
# Check provider endpoints
curl http://localhost:8126/v0.4/traces  # Datadog agent
curl http://localhost:8080/metrics      # Prometheus metrics
```

## Migration Strategies

### 1. Gradual Migration
```go
// Week 1: Add new provider alongside existing
providers := []tracer.Tracer{existingProvider, newProvider}

// Week 2-4: Compare data and validate
validateProviderData(existingProvider, newProvider)

// Week 5: Switch primary provider
primaryProvider = newProvider

// Week 6: Remove old provider
providers = []tracer.Tracer{newProvider}
```

### 2. A/B Testing
```go
// Route traffic based on user ID
if userID % 100 < 50 {
    providers = []tracer.Tracer{providerA}
} else {
    providers = []tracer.Tracer{providerB}
}
```

## Best Practices

1. **Start Simple**: Begin with one provider, add others gradually
2. **Monitor Overhead**: Track performance impact of multiple providers
3. **Consistent Naming**: Use consistent attribute names across providers
4. **Provider-Specific Features**: Leverage each provider's strengths
5. **Graceful Degradation**: Handle provider failures gracefully
6. **Cost Management**: Monitor costs across all providers
7. **Data Governance**: Ensure consistent data handling policies

## Next Steps

1. **Cost Analysis**: Compare costs of running multiple providers
2. **Custom Dashboards**: Create unified dashboards combining data from all providers
3. **Alerting Strategy**: Develop comprehensive alerting across providers
4. **Data Pipeline**: Consider building unified data pipeline for analysis
5. **Provider Evaluation**: Use multi-provider setup to evaluate and compare tools
